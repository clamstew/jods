"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5],{3774:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6672);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}},4411:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"guides/complex-state-patterns","title":"Complex State Patterns","description":"Best practices for managing complex state structures in jods","source":"@site/docs/guides/complex-state-patterns.md","sourceDirName":"guides","slug":"/guides/complex-state-patterns","permalink":"/fr/guides/complex-state-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/guides/complex-state-patterns.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Complex State Patterns","description":"Best practices for managing complex state structures in jods"}}');var s=t(3420),a=t(3774);const o={sidebar_position:3,title:"Complex State Patterns",description:"Best practices for managing complex state structures in jods"},i="Complex State Patterns",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Structuring Complex State",id:"structuring-complex-state",level:2},{value:"Domain-Based Organization",id:"domain-based-organization",level:3},{value:"Normalized State",id:"normalized-state",level:3},{value:"State Slices for Large Applications",id:"state-slices-for-large-applications",level:3},{value:"Managing Complex State Updates",id:"managing-complex-state-updates",level:2},{value:"Computed Properties for Derived State",id:"computed-properties-for-derived-state",level:3},{value:"State Mutations with Helper Functions",id:"state-mutations-with-helper-functions",level:3},{value:"Handling Asynchronous Updates",id:"handling-asynchronous-updates",level:3},{value:"Handling Edge Cases",id:"handling-edge-cases",level:2},{value:"Deep Objects with Circular References",id:"deep-objects-with-circular-references",level:3},{value:"Large Collections",id:"large-collections",level:3},{value:"Real-World Patterns",id:"real-world-patterns",level:2},{value:"Form State Management",id:"form-state-management",level:3},{value:"Authentication State",id:"authentication-state",level:3},{value:"Testing Complex State",id:"testing-complex-state",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"complex-state-patterns",children:"Complex State Patterns"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"As applications grow in complexity, managing state becomes increasingly challenging. This guide explores optimal patterns for structuring and managing complex state in jods, helping you avoid common pitfalls and leverage the library's strengths."}),"\n",(0,s.jsx)(n.h2,{id:"structuring-complex-state",children:"Structuring Complex State"}),"\n",(0,s.jsx)(n.h3,{id:"domain-based-organization",children:"Domain-Based Organization"}),"\n",(0,s.jsx)(n.p,{children:"Organize your state based on domain concepts rather than UI components:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { store } from "jods";\n\n// \u2705 Domain-based organization\nconst appStore = store({\n  users: {\n    current: null,\n    list: [],\n    online: [],\n  },\n  products: {\n    items: [],\n    categories: [],\n    featured: [],\n  },\n  cart: {\n    items: [],\n    discounts: [],\n    summary: {},\n  },\n  ui: {\n    theme: "light",\n    sidebar: "expanded",\n    modals: {},\n  },\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"This approach makes your state more navigable and conceptually clear."}),"\n",(0,s.jsx)(n.h3,{id:"normalized-state",children:"Normalized State"}),"\n",(0,s.jsx)(n.p,{children:"For complex relational data, consider a normalized approach:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// \u274c Nested and redundant\nconst messyStore = store({\n  posts: [\n    {\n      id: 1,\n      title: "First Post",\n      author: { id: 101, name: "Alice", bio: "..." },\n      comments: [\n        { id: 201, text: "Great post!", author: { id: 102, name: "Bob" } },\n      ],\n    },\n  ],\n});\n\n// \u2705 Normalized\nconst normalizedStore = store({\n  entities: {\n    users: {\n      101: { id: 101, name: "Alice", bio: "..." },\n      102: { id: 102, name: "Bob", bio: "..." },\n    },\n    posts: {\n      1: { id: 1, title: "First Post", authorId: 101, commentIds: [201] },\n    },\n    comments: {\n      201: { id: 201, text: "Great post!", authorId: 102, postId: 1 },\n    },\n  },\n  ui: {\n    currentPostId: 1,\n  },\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of normalization:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Eliminates data duplication"}),"\n",(0,s.jsx)(n.li,{children:"Makes updates more predictable"}),"\n",(0,s.jsx)(n.li,{children:"Improves performance for large datasets"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"state-slices-for-large-applications",children:"State Slices for Large Applications"}),"\n",(0,s.jsx)(n.p,{children:"For very large applications, consider splitting state into logical slices:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { store } from "jods";\n\nconst userStore = store({\n  current: null,\n  preferences: {},\n  permissions: {},\n  history: [],\n});\n\nconst productStore = store({\n  catalog: [],\n  featured: [],\n  filters: {},\n});\n\nconst cartStore = store({\n  items: [],\n  shipping: {},\n  payment: {},\n});\n\n// Connect stores when needed\nuserStore.subscribe(() => {\n  if (userStore.current && userStore.current.cart) {\n    cartStore.hydrate(userStore.current.cart);\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"managing-complex-state-updates",children:"Managing Complex State Updates"}),"\n",(0,s.jsx)(n.h3,{id:"computed-properties-for-derived-state",children:"Computed Properties for Derived State"}),"\n",(0,s.jsx)(n.p,{children:"Use computed properties for any state that can be derived from other state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { store, computed } from "jods";\n\nconst appStore = store({\n  cart: {\n    items: [],\n    taxRate: 0.08,\n  },\n});\n\n// Add computed properties for derived values\nappStore.cart.subtotal = computed(() => {\n  return appStore.cart.items.reduce(\n    (sum, item) => sum + item.price * item.quantity,\n    0\n  );\n});\n\nappStore.cart.tax = computed(() => {\n  return appStore.cart.subtotal * appStore.cart.taxRate;\n});\n\nappStore.cart.total = computed(() => {\n  return appStore.cart.subtotal + appStore.cart.tax;\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"state-mutations-with-helper-functions",children:"State Mutations with Helper Functions"}),"\n",(0,s.jsx)(n.p,{children:"For complex mutations, create helper functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function addToCart(productId, quantity = 1) {\n  const product = appStore.products.items.find((p) => p.id === productId);\n  if (!product) return false;\n\n  const existingItem = appStore.cart.items.find(\n    (item) => item.id === productId\n  );\n\n  if (existingItem) {\n    // Update existing item\n    const index = appStore.cart.items.indexOf(existingItem);\n    appStore.cart.items[index] = {\n      ...existingItem,\n      quantity: existingItem.quantity + quantity,\n    };\n  } else {\n    // Add new item\n    appStore.cart.items.push({\n      id: product.id,\n      name: product.name,\n      price: product.price,\n      quantity: quantity,\n    });\n  }\n\n  return true;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"handling-asynchronous-updates",children:"Handling Asynchronous Updates"}),"\n",(0,s.jsx)(n.p,{children:"Pattern for handling async operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { store } from "jods";\n\nconst appStore = store({\n  users: {\n    list: [],\n    loading: false,\n    error: null,\n  },\n});\n\nasync function fetchUsers() {\n  // Set loading state\n  appStore.users.loading = true;\n  appStore.users.error = null;\n\n  try {\n    const response = await fetch("/api/users");\n    if (!response.ok) throw new Error("Failed to fetch users");\n\n    const data = await response.json();\n    // Update store with fetched data\n    appStore.users.list = data;\n    appStore.users.loading = false;\n  } catch (err) {\n    // Handle error state\n    appStore.users.error = err.message;\n    appStore.users.loading = false;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"handling-edge-cases",children:"Handling Edge Cases"}),"\n",(0,s.jsx)(n.h3,{id:"deep-objects-with-circular-references",children:"Deep Objects with Circular References"}),"\n",(0,s.jsx)(n.p,{children:"jods handles circular references properly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const teamStore = store({\n  members: [],\n});\n\n// Create a circular reference\nconst alice = { id: 1, name: "Alice" };\nconst bob = { id: 2, name: "Bob", manager: alice };\nalice.reports = [bob];\n\n// jods handles this correctly\nteamStore.members = [alice, bob];\n\n// Even snapshots work properly\nconst snapshot = teamStore.json();\n// Circular references are preserved with special marking\n'})}),"\n",(0,s.jsx)(n.h3,{id:"large-collections",children:"Large Collections"}),"\n",(0,s.jsx)(n.p,{children:"For large collections, consider pagination or virtualization strategies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const dataStore = store({\n  allItems: [], // Full dataset (could be thousands of items)\n  pagination: {\n    pageSize: 20,\n    currentPage: 1,\n  },\n  // Computed property for current page items\n  currentPageItems: computed(() => {\n    const { pageSize, currentPage } = dataStore.pagination;\n    const startIndex = (currentPage - 1) * pageSize;\n    return dataStore.allItems.slice(startIndex, startIndex + pageSize);\n  }),\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-patterns",children:"Real-World Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"form-state-management",children:"Form State Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const formStore = store({\n  values: {\n    username: "",\n    email: "",\n    password: "",\n  },\n  touched: {\n    username: false,\n    email: false,\n    password: false,\n  },\n  errors: {},\n});\n\n// Computed validation\nformStore.errors = computed(() => {\n  const errors = {};\n  const { username, email, password } = formStore.values;\n\n  if (!username) errors.username = "Username is required";\n  if (!email) errors.email = "Email is required";\n  else if (!/\\S+@\\S+\\.\\S+/.test(email)) errors.email = "Email is invalid";\n  if (!password) errors.password = "Password is required";\n  else if (password.length < 8)\n    errors.password = "Password must be at least 8 characters";\n\n  return errors;\n});\n\nformStore.isValid = computed(() => {\n  return Object.keys(formStore.errors).length === 0;\n});\n\n// Field update function\nfunction updateField(field, value) {\n  formStore.values[field] = value;\n  formStore.touched[field] = true;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"authentication-state",children:"Authentication State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const authStore = store({\n  user: null,\n  token: null,\n  loading: false,\n  error: null,\n});\n\nauthStore.isAuthenticated = computed(() => {\n  return !!authStore.token && !!authStore.user;\n});\n\n// Auth operations\nasync function login(credentials) {\n  authStore.loading = true;\n  authStore.error = null;\n\n  try {\n    const response = await fetch("/api/login", {\n      method: "POST",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify(credentials),\n    });\n\n    if (!response.ok) throw new Error("Login failed");\n\n    const data = await response.json();\n    authStore.user = data.user;\n    authStore.token = data.token;\n    localStorage.setItem("auth_token", data.token);\n  } catch (err) {\n    authStore.error = err.message;\n  } finally {\n    authStore.loading = false;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-complex-state",children:"Testing Complex State"}),"\n",(0,s.jsx)(n.p,{children:"Creating testable state structures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { store } from "jods";\n\n// Create a factory function for consistent store initialization\nfunction createAppStore(initialState = {}) {\n  return store({\n    users: { list: [], current: null },\n    products: { items: [] },\n    ...initialState,\n  });\n}\n\n// In tests\ndescribe("App Store", () => {\n  let testStore;\n\n  beforeEach(() => {\n    testStore = createAppStore({\n      users: {\n        list: [{ id: 1, name: "Test User" }],\n      },\n    });\n  });\n\n  test("should add a product to store", () => {\n    const newProduct = { id: 1, name: "Test Product" };\n    testStore.products.items.push(newProduct);\n    expect(testStore.products.items).toContainEqual(newProduct);\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Building complex applications with jods is straightforward when following these patterns. Remember that:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"State organization should reflect your domain"}),"\n",(0,s.jsx)(n.li,{children:"Computed properties should handle derived state"}),"\n",(0,s.jsx)(n.li,{children:"Normalized state improves maintainability for relational data"}),"\n",(0,s.jsx)(n.li,{children:"Helper functions can encapsulate complex state transitions"}),"\n",(0,s.jsx)(n.li,{children:"Clear patterns for async operations keep your code predictable"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By following these guidelines, you can build robust, maintainable applications of any complexity while leveraging jods' reactive capabilities."}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/fr/guides/performance-best-practices",children:"Performance Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/fr/api-reference",children:"API Reference"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/fr/fine-grained-reactivity",children:"Fine-Grained Reactivity"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);