"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3994],{3774:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var r=n(6672);const a={},o=r.createContext(a);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:t},e.children)}},4711:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"storage-adapters","title":"\ud83d\uddc4\ufe0f Storage Adapters","description":"jods persistence works with any storage mechanism that implements the standard storage interface. This document covers the various storage adapters you can use with the persist() API.","source":"@site/docs/storage-adapters.md","sourceDirName":".","slug":"/storage-adapters","permalink":"/fr/storage-adapters","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/storage-adapters.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"jodsSidebar","previous":{"title":"\ud83d\udcbe State Persistence","permalink":"/fr/state-persistence"},"next":{"title":"\ud83e\uddec Fine-Grained Reactivity","permalink":"/fr/fine-grained-reactivity"}}');var a=n(3420),o=n(3774);const s={sidebar_position:7},i="\ud83d\uddc4\ufe0f Storage Adapters",c={},l=[{value:"Storage Interface",id:"storage-interface",level:2},{value:"Built-in Browser Storage",id:"built-in-browser-storage",level:2},{value:"localStorage",id:"localstorage",level:3},{value:"sessionStorage",id:"sessionstorage",level:3},{value:"Custom Storage Adapters",id:"custom-storage-adapters",level:2},{value:"IndexedDB Adapter",id:"indexeddb-adapter",level:3},{value:"Web API Storage Adapter",id:"web-api-storage-adapter",level:3},{value:"In-Memory Storage Adapter",id:"in-memory-storage-adapter",level:3},{value:"Framework-Specific Storage Adapters",id:"framework-specific-storage-adapters",level:2},{value:"Remix Cookie Storage",id:"remix-cookie-storage",level:3},{value:"Storage Patterns",id:"storage-patterns",level:2},{value:"Composite Storage",id:"composite-storage",level:3},{value:"Encrypted Storage",id:"encrypted-storage",level:3},{value:"Quota Management Storage",id:"quota-management-storage",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Storage Availability Detection",id:"storage-availability-detection",level:3},{value:"Data Compression",id:"data-compression",level:3},{value:"Testing Storage Adapters",id:"testing-storage-adapters",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"\ufe0f-storage-adapters",children:"\ud83d\uddc4\ufe0f Storage Adapters"})}),"\n",(0,a.jsxs)(t.p,{children:["jods persistence works with any storage mechanism that implements the standard storage interface. This document covers the various storage adapters you can use with the ",(0,a.jsx)(t.code,{children:"persist()"})," API."]}),"\n",(0,a.jsx)(t.h2,{id:"storage-interface",children:"Storage Interface"}),"\n",(0,a.jsx)(t.p,{children:"A valid storage adapter must implement this interface:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"interface PersistStorage {\n  getItem(key: string): string | null | Promise<string | null>;\n  setItem(key: string, value: string): void | Promise<void>;\n  removeItem(key: string): void | Promise<void>;\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"The storage interface supports both synchronous and asynchronous implementations - jods automatically detects which mode to use based on the return type of the methods."}),"\n",(0,a.jsx)(t.h2,{id:"built-in-browser-storage",children:"Built-in Browser Storage"}),"\n",(0,a.jsx)(t.h3,{id:"localstorage",children:"localStorage"}),"\n",(0,a.jsx)(t.p,{children:"Persists data indefinitely until explicitly cleared:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { store, persist } from "jods";\nconst settings = store({\n  theme: "light",\n  fontSize: 16,\n});\n\n// Persist to localStorage\npersist(localStorage, settings, { key: "app-settings" });\n'})}),"\n",(0,a.jsx)(t.h3,{id:"sessionstorage",children:"sessionStorage"}),"\n",(0,a.jsx)(t.p,{children:"Persists data for the duration of the page session (until the tab is closed):"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { store, persist } from "jods";\n\nconst temporaryState = store({\n  currentStep: 1,\n  formValues: {},\n});\n\n// Persist to sessionStorage\npersist(sessionStorage, temporaryState, { key: "wizard-state" });\n'})}),"\n",(0,a.jsx)(t.h2,{id:"custom-storage-adapters",children:"Custom Storage Adapters"}),"\n",(0,a.jsx)(t.h3,{id:"indexeddb-adapter",children:"IndexedDB Adapter"}),"\n",(0,a.jsx)(t.p,{children:"You can use the built-in adapter:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { store, persist } from "jods";\nimport { createIndexedDBStorage } from "jods/persist/adapters";\n\nconst userStore = store({ name: "User", preferences: {} });\nconst dbStorage = createIndexedDBStorage("myAppDB", "userSettings");\n\npersist(dbStorage, userStore, { key: "user-data" });\n'})}),"\n",(0,a.jsx)(t.p,{children:"Or implement your own custom version:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// IndexedDB storage adapter\nconst createIndexedDBStorage = (dbName, storeName) => {\n  // Open database connection\n  const openDB = () => {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(dbName, 1);\n\n      request.onupgradeneeded = () => {\n        const db = request.result;\n        if (!db.objectStoreNames.contains(storeName)) {\n          db.createObjectStore(storeName);\n        }\n      };\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  };\n\n  return {\n    async getItem(key) {\n      const db = await openDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, "readonly");\n        const store = transaction.objectStore(storeName);\n        const request = store.get(key);\n\n        request.onsuccess = () => resolve(request.result || null);\n        request.onerror = () => reject(request.error);\n\n        // Clean up by closing the database once transaction completes\n        transaction.oncomplete = () => db.close();\n      });\n    },\n\n    async setItem(key, value) {\n      const db = await openDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, "readwrite");\n        const store = transaction.objectStore(storeName);\n        const request = store.put(value, key);\n\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n\n        // Clean up by closing the database once transaction completes\n        transaction.oncomplete = () => db.close();\n      });\n    },\n\n    async removeItem(key) {\n      const db = await openDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, "readwrite");\n        const store = transaction.objectStore(storeName);\n        const request = store.delete(key);\n\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n\n        // Clean up by closing the database once transaction completes\n        transaction.oncomplete = () => db.close();\n      });\n    },\n  };\n};\n\n// Usage\nconst indexedDBStorage = createIndexedDBStorage("myAppDB", "appState");\npersist(indexedDBStorage, myStore, { key: "state" });\n'})}),"\n",(0,a.jsx)(t.h3,{id:"web-api-storage-adapter",children:"Web API Storage Adapter"}),"\n",(0,a.jsx)(t.p,{children:"You can use the built-in adapter:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { store, persist } from "jods";\nimport { createAPIStorage } from "jods/persist/adapters";\n\nconst settingsStore = store({ theme: "dark", fontSize: 16 });\nconst apiStorage = createAPIStorage(\n  "https://api.example.com/state",\n  "user-auth-token"\n);\n\npersist(apiStorage, settingsStore, { key: "settings" });\n'})}),"\n",(0,a.jsx)(t.p,{children:"Or implement your own custom version:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// REST API storage adapter\nconst createAPIStorage = (endpoint, authToken) => {\n  return {\n    async getItem(key) {\n      try {\n        const response = await fetch(`${endpoint}/${key}`, {\n          headers: {\n            Authorization: `Bearer ${authToken}`,\n            "Content-Type": "application/json",\n          },\n        });\n\n        if (!response.ok) {\n          if (response.status === 404) {\n            return null; // Item not found\n          }\n          throw new Error(`API error: ${response.status}`);\n        }\n\n        const data = await response.text();\n        return data;\n      } catch (error) {\n        console.error("Failed to get item:", error);\n        return null;\n      }\n    },\n\n    async setItem(key, value) {\n      try {\n        const response = await fetch(`${endpoint}/${key}`, {\n          method: "PUT",\n          headers: {\n            Authorization: `Bearer ${authToken}`,\n            "Content-Type": "application/json",\n          },\n          body: value,\n        });\n\n        if (!response.ok) {\n          throw new Error(`API error: ${response.status}`);\n        }\n      } catch (error) {\n        console.error("Failed to set item:", error);\n        throw error;\n      }\n    },\n\n    async removeItem(key) {\n      try {\n        const response = await fetch(`${endpoint}/${key}`, {\n          method: "DELETE",\n          headers: {\n            Authorization: `Bearer ${authToken}`,\n            "Content-Type": "application/json",\n          },\n        });\n\n        if (!response.ok) {\n          throw new Error(`API error: ${response.status}`);\n        }\n      } catch (error) {\n        console.error("Failed to remove item:", error);\n        throw error;\n      }\n    },\n  };\n};\n\n// Usage\nconst apiStorage = createAPIStorage(\n  "https://api.example.com/state",\n  "user-auth-token"\n);\npersist(apiStorage, userSettings, { key: "settings" });\n'})}),"\n",(0,a.jsx)(t.h3,{id:"in-memory-storage-adapter",children:"In-Memory Storage Adapter"}),"\n",(0,a.jsx)(t.p,{children:"Useful for testing or temporary storage:"}),"\n",(0,a.jsx)(t.p,{children:"You can use the built-in adapter:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { store, persist } from "jods";\nimport { createMemoryStorage } from "jods/persist/adapters";\n\nconst tempStore = store({ value: "temporary" });\nconst memoryStorage = createMemoryStorage();\n\npersist(memoryStorage, tempStore, { key: "temp" });\n\n// The memory storage has additional helper methods\nmemoryStorage.clear(); // Clear all data\nconst allData = memoryStorage.getAll(); // Get all stored data\n'})}),"\n",(0,a.jsx)(t.p,{children:"Or implement your own custom version:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// In-memory storage adapter\nconst createMemoryStorage = (initialData = {}) => {\n  let storage = { ...initialData };\n\n  return {\n    getItem(key) {\n      return storage[key] || null;\n    },\n\n    setItem(key, value) {\n      storage[key] = value;\n    },\n\n    removeItem(key) {\n      delete storage[key];\n    },\n\n    // Helper method to clear all data (not required by the interface)\n    clear() {\n      storage = {};\n    },\n  };\n};\n\n// Usage\nconst memoryStorage = createMemoryStorage();\npersist(memoryStorage, tempStore, { key: "temp" });\n'})}),"\n",(0,a.jsx)(t.h2,{id:"framework-specific-storage-adapters",children:"Framework-Specific Storage Adapters"}),"\n",(0,a.jsx)(t.h3,{id:"remix-cookie-storage",children:"Remix Cookie Storage"}),"\n",(0,a.jsx)(t.p,{children:"For server-side persistence in Remix applications:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { createCookieStorage } from "jods/remix";\nimport { json } from "@remix-run/node";\n\n// Create cookie storage\nconst cookieStorage = createCookieStorage({\n  cookie: {\n    name: "app_session",\n    secrets: ["your-secret-key"],\n    sameSite: "lax",\n    path: "/",\n    maxAge: 60 * 60 * 24 * 7, // 1 week\n  },\n});\n\n// In your loader\nexport async function loader({ request }) {\n  // Load persisted data from cookie\n  const persistedData = await cookieStorage.getItem("user-prefs");\n\n  // Parse and use the data\n  if (persistedData) {\n    try {\n      const parsedData = JSON.parse(persistedData);\n      // Do something with the data...\n    } catch (e) {\n      console.error("Failed to parse persisted data", e);\n    }\n  }\n\n  return json({\n    /* your response */\n  });\n}\n\n// In your action\nexport async function action({ request }) {\n  // Update data\n  const formData = await request.formData();\n\n  // Create response with headers\n  const headers = new Headers();\n  await cookieStorage.setItem(\n    "user-prefs",\n    JSON.stringify({\n      theme: formData.get("theme"),\n    }),\n    { headers }\n  );\n\n  return json({ success: true }, { headers });\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"storage-patterns",children:"Storage Patterns"}),"\n",(0,a.jsx)(t.h3,{id:"composite-storage",children:"Composite Storage"}),"\n",(0,a.jsx)(t.p,{children:"Combine multiple storage mechanisms:"}),"\n",(0,a.jsx)(t.p,{children:"You can use the built-in adapter:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { store, persist } from "jods";\nimport {\n  createFallbackStorage,\n  createMemoryStorage,\n} from "jods/persist/adapters";\n\n// Create a storage that tries localStorage first, falls back to sessionStorage,\n// and finally falls back to memory storage\nconst fallbackStorage = createFallbackStorage([\n  localStorage,\n  sessionStorage,\n  createMemoryStorage(),\n]);\n\nconst appState = store({\n  theme: "light",\n  fontSize: 16,\n});\n\npersist(fallbackStorage, appState, { key: "app-state" });\n'})}),"\n",(0,a.jsx)(t.p,{children:"Or implement your own custom version:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// Storage that tries localStorage first, falls back to sessionStorage,\n// and finally falls back to memory storage\nconst createFallbackStorage = () => {\n  const memoryStorage = createMemoryStorage();\n\n  const isStorageAvailable = (storage) => {\n    try {\n      storage.setItem("test", "test");\n      storage.removeItem("test");\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  const localStorageAvailable =\n    typeof window !== "undefined" && isStorageAvailable(localStorage);\n  const sessionStorageAvailable =\n    typeof window !== "undefined" && isStorageAvailable(sessionStorage);\n\n  return {\n    async getItem(key) {\n      if (localStorageAvailable) {\n        const value = localStorage.getItem(key);\n        if (value !== null) return value;\n      }\n\n      if (sessionStorageAvailable) {\n        const value = sessionStorage.getItem(key);\n        if (value !== null) return value;\n      }\n\n      return memoryStorage.getItem(key);\n    },\n\n    async setItem(key, value) {\n      if (localStorageAvailable) {\n        try {\n          localStorage.setItem(key, value);\n          return;\n        } catch (e) {\n          console.warn(\n            "localStorage setItem failed, falling back to sessionStorage"\n          );\n        }\n      }\n\n      if (sessionStorageAvailable) {\n        try {\n          sessionStorage.setItem(key, value);\n          return;\n        } catch (e) {\n          console.warn(\n            "sessionStorage setItem failed, falling back to memory storage"\n          );\n        }\n      }\n\n      memoryStorage.setItem(key, value);\n    },\n\n    async removeItem(key) {\n      if (localStorageAvailable) {\n        localStorage.removeItem(key);\n      }\n\n      if (sessionStorageAvailable) {\n        sessionStorage.removeItem(key);\n      }\n\n      memoryStorage.removeItem(key);\n    },\n  };\n};\n\n// Usage\nconst fallbackStorage = createFallbackStorage();\npersist(fallbackStorage, appState, { key: "app-state" });\n'})}),"\n",(0,a.jsx)(t.h3,{id:"encrypted-storage",children:"Encrypted Storage"}),"\n",(0,a.jsx)(t.p,{children:"Add encryption for sensitive data:"}),"\n",(0,a.jsx)(t.p,{children:"You can use the built-in adapter (note that the built-in encryption is basic and for demonstration purposes only):"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import { store, persist } from "jods";\nimport { createEncryptedStorage } from "jods/persist/adapters";\n\n// Basic usage with built-in encryption (for non-sensitive data only)\nconst secureStorage = createEncryptedStorage(localStorage, "my-secret-key");\n\n// For production/sensitive data, use a proper encryption library\nimport CryptoJS from "crypto-js";\n\nconst productionSecureStorage = createEncryptedStorage(\n  localStorage,\n  "my-secret-key",\n  {\n    encrypt: (text, secret) => CryptoJS.AES.encrypt(text, secret).toString(),\n    decrypt: (encrypted, secret) => {\n      try {\n        const bytes = CryptoJS.AES.decrypt(encrypted, secret);\n        return bytes.toString(CryptoJS.enc.Utf8);\n      } catch (e) {\n        return null;\n      }\n    },\n  }\n);\n\nconst appSettings = store({\n  username: "user123",\n  preferences: { theme: "dark" },\n});\n\npersist(productionSecureStorage, appSettings, { key: "secure-settings" });\n'})}),"\n",(0,a.jsx)(t.p,{children:"Or implement your own custom version:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// Simple encryption example (NOTE: not production-ready)\nconst createEncryptedStorage = (baseStorage, secret) => {\n  // Simple encryption/decryption functions\n  const encrypt = (text) => {\n    // In a real app, use a proper encryption library\n    // This is just a demonstration\n    return btoa(\n      text\n        .split("")\n        .map((char) =>\n          String.fromCharCode(char.charCodeAt(0) + (secret.charCodeAt(0) % 10))\n        )\n        .join("")\n    );\n  };\n\n  const decrypt = (encryptedText) => {\n    try {\n      // In a real app, use a proper encryption library\n      // This is just a demonstration\n      return atob(encryptedText)\n        .split("")\n        .map((char) =>\n          String.fromCharCode(char.charCodeAt(0) - (secret.charCodeAt(0) % 10))\n        )\n        .join("");\n    } catch (e) {\n      console.error("Failed to decrypt data");\n      return null;\n    }\n  };\n\n  return {\n    async getItem(key) {\n      const encryptedData = await baseStorage.getItem(key);\n      if (!encryptedData) return null;\n      return decrypt(encryptedData);\n    },\n\n    async setItem(key, value) {\n      const encryptedValue = encrypt(value);\n      await baseStorage.setItem(key, encryptedValue);\n    },\n\n    async removeItem(key) {\n      await baseStorage.removeItem(key);\n    },\n  };\n};\n\n// Usage\nconst encryptedStorage = createEncryptedStorage(localStorage, "my-secret-key");\npersist(encryptedStorage, appSettings, { key: "secure-settings" });\n'})}),"\n",(0,a.jsx)(t.h3,{id:"quota-management-storage",children:"Quota Management Storage"}),"\n",(0,a.jsx)(t.p,{children:"Handle storage quota limits:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// Storage adapter that handles quota exceeded errors\nconst createQuotaManagementStorage = (baseStorage, quotaErrorHandler) => {\n  return {\n    async getItem(key) {\n      return baseStorage.getItem(key);\n    },\n\n    async setItem(key, value) {\n      try {\n        await baseStorage.setItem(key, value);\n      } catch (error) {\n        // Check if it\'s a quota error\n        if (\n          error instanceof DOMException &&\n          (error.code === 22 ||\n            error.code === 1014 ||\n            error.name === "QuotaExceededError" ||\n            error.name === "NS_ERROR_DOM_QUOTA_REACHED")\n        ) {\n          // Call the handler to deal with the quota error\n          if (quotaErrorHandler) {\n            await quotaErrorHandler(key, value, baseStorage);\n          } else {\n            throw error; // Re-throw if no handler\n          }\n        } else {\n          throw error; // Other errors\n        }\n      }\n    },\n\n    async removeItem(key) {\n      return baseStorage.removeItem(key);\n    },\n  };\n};\n\n// Example handler that removes old items to make space\nconst handleQuotaError = async (key, value, storage) => {\n  try {\n    // Get a list of all keys (implementation depends on your storage)\n    const allKeys = Object.keys(localStorage);\n\n    // Sort by some priority (example: older items first)\n    const oldestKey = allKeys\n      .filter((k) => k !== key && k.startsWith("app-"))\n      .sort()[0];\n\n    if (oldestKey) {\n      // Remove an old item to make space\n      await storage.removeItem(oldestKey);\n      console.log(`Removed ${oldestKey} to make space`);\n\n      // Try again\n      await storage.setItem(key, value);\n    } else {\n      throw new Error("Storage quota exceeded and no items to remove");\n    }\n  } catch (e) {\n    console.error("Failed to handle quota error:", e);\n    throw e;\n  }\n};\n\n// Usage\nconst quotaStorage = createQuotaManagementStorage(\n  localStorage,\n  handleQuotaError\n);\npersist(quotaStorage, largeDataStore, { key: "large-data" });\n'})}),"\n",(0,a.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(t.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(t.p,{children:"Always include error handling with your storage adapters:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const createRobustStorage = (baseStorage) => {\n  return {\n    async getItem(key) {\n      try {\n        return await baseStorage.getItem(key);\n      } catch (error) {\n        console.error(`Failed to get item ${key}:`, error);\n        return null;\n      }\n    },\n\n    async setItem(key, value) {\n      try {\n        await baseStorage.setItem(key, value);\n      } catch (error) {\n        console.error(`Failed to set item ${key}:`, error);\n        // You might want to retry, fallback to another storage, or notify the user\n        throw error;\n      }\n    },\n\n    async removeItem(key) {\n      try {\n        await baseStorage.removeItem(key);\n      } catch (error) {\n        console.error(`Failed to remove item ${key}:`, error);\n        // Handle error appropriately\n      }\n    },\n  };\n};\n"})}),"\n",(0,a.jsx)(t.h3,{id:"storage-availability-detection",children:"Storage Availability Detection"}),"\n",(0,a.jsx)(t.p,{children:"Always check if storage is available before using it:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'const isStorageAvailable = (type) => {\n  try {\n    const storage = window[type];\n    const testKey = "__storage_test__";\n    storage.setItem(testKey, testKey);\n    storage.removeItem(testKey);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n// Usage\nconst storage = isStorageAvailable("localStorage")\n  ? localStorage\n  : createMemoryStorage();\npersist(storage, myStore, { key: "app-data" });\n'})}),"\n",(0,a.jsx)(t.h3,{id:"data-compression",children:"Data Compression"}),"\n",(0,a.jsx)(t.p,{children:"For large state objects, consider compressing the data:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// Example using a simple compression library (you would need to include such a library)\nconst createCompressedStorage = (baseStorage) => {\n  return {\n    async getItem(key) {\n      const compressedData = await baseStorage.getItem(key);\n      if (!compressedData) return null;\n\n      try {\n        // Use your compression library here\n        return decompressData(compressedData);\n      } catch (error) {\n        console.error("Failed to decompress data:", error);\n        return null;\n      }\n    },\n\n    async setItem(key, value) {\n      try {\n        // Use your compression library here\n        const compressed = compressData(value);\n        await baseStorage.setItem(key, compressed);\n      } catch (error) {\n        console.error("Failed to compress or save data:", error);\n        throw error;\n      }\n    },\n\n    async removeItem(key) {\n      await baseStorage.removeItem(key);\n    },\n  };\n};\n\n// These functions would use your chosen compression library\nfunction compressData(data) {\n  // Example implementation with a hypothetical compression library\n  return LZString.compress(data);\n}\n\nfunction decompressData(compressedData) {\n  // Example implementation with a hypothetical compression library\n  return LZString.decompress(compressedData);\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"testing-storage-adapters",children:"Testing Storage Adapters"}),"\n",(0,a.jsx)(t.p,{children:"Create mock storage adapters for testing:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// Mock storage for testing\nconst createMockStorage = (initialData = {}) => {\n  let storage = { ...initialData };\n\n  return {\n    getItem: jest.fn((key) => storage[key] || null),\n    setItem: jest.fn((key, value) => {\n      storage[key] = value;\n    }),\n    removeItem: jest.fn((key) => {\n      delete storage[key];\n    }),\n\n    // Helper methods for testing\n    _getData: () => ({ ...storage }),\n    _clear: () => {\n      storage = {};\n    },\n    _resetMocks: () => {\n      jest.clearAllMocks();\n    },\n  };\n};\n\n// Usage in tests\ndescribe("persistence tests", () => {\n  let mockStorage;\n  let testStore;\n\n  beforeEach(() => {\n    mockStorage = createMockStorage({ "existing-key": "existing-value" });\n    testStore = store({ count: 0 });\n  });\n\n  test("should persist store changes to storage", () => {\n    persist(mockStorage, testStore, { key: "test-store" });\n\n    // Modify the store\n    testStore.count = 42;\n\n    // Check that setItem was called with the correct data\n    expect(mockStorage.setItem).toHaveBeenCalled();\n    expect(JSON.parse(mockStorage.setItem.mock.calls[0][1])).toEqual({\n      count: 42,\n    });\n  });\n});\n'})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"By implementing custom storage adapters, you can persist jods state to virtually any storage mechanism, from browser storage to remote APIs, databases, or even custom systems. The flexible interface makes it easy to add persistence to your application while maintaining control over where and how your data is stored."})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);