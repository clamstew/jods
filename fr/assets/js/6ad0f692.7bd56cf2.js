"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9609],{3774:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6672);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},6074:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"fine-grained-reactivity","title":"\ud83e\uddec Fine-grained Reactivity","description":"JODS uses a signal-based reactive system to provide efficient, fine-grained updates to subscribers. This optimization ensures that subscribers are only notified when the specific data they depend on changes.","source":"@site/docs/fine-grained-reactivity.md","sourceDirName":".","slug":"/fine-grained-reactivity","permalink":"/fr/fine-grained-reactivity","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/fine-grained-reactivity.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"jodsSidebar","previous":{"title":"\ud83d\uddc4\ufe0f Storage Adapters","permalink":"/fr/storage-adapters"},"next":{"title":"\ud83d\udd0b Batch Updates","permalink":"/fr/batch"}}');var i=s(3420),r=s(3774);const a={sidebar_position:6},o="\ud83e\uddec Fine-grained Reactivity",c={},d=[{value:"\ud83e\udd14 How It Works",id:"-how-it-works",level:2},{value:"\ud83d\udce1 Signal-based Architecture",id:"-signal-based-architecture",level:3},{value:"\ud83d\ude80 Benefits",id:"-benefits",level:2},{value:"\ud83d\udd04 Subscription Behavior",id:"-subscription-behavior",level:2},{value:"\ud83c\udfaf Dynamic Dependencies",id:"-dynamic-dependencies",level:3},{value:"\ud83d\uddd1\ufe0f Unsubscribe Behavior",id:"\ufe0f-unsubscribe-behavior",level:3},{value:"\ud83d\udca1 Examples",id:"-examples",level:2},{value:"\ud83d\udfe2 Basic Example",id:"-basic-example",level:3},{value:"\u269b\ufe0f React Component Example",id:"\ufe0f-react-component-example",level:3},{value:"\ud83d\udee0\ufe0f Technical Implementation",id:"\ufe0f-technical-implementation",level:2},{value:"\u2696\ufe0f Comparison with Other Approaches",id:"\ufe0f-comparison-with-other-approaches",level:2},{value:"\ud83d\udc4d Best Practices",id:"-best-practices",level:2},{value:"\ud83c\udf33 Deep Nesting and Arrays",id:"-deep-nesting-and-arrays",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"-fine-grained-reactivity",children:"\ud83e\uddec Fine-grained Reactivity"})}),"\n",(0,i.jsx)(n.p,{children:"JODS uses a signal-based reactive system to provide efficient, fine-grained updates to subscribers. This optimization ensures that subscribers are only notified when the specific data they depend on changes."}),"\n",(0,i.jsx)(n.h2,{id:"-how-it-works",children:"\ud83e\udd14 How It Works"}),"\n",(0,i.jsx)(n.p,{children:"Unlike many state management libraries that notify all subscribers whenever any part of the state changes, JODS tracks which properties each subscriber actually uses and only triggers updates when those specific properties change."}),"\n",(0,i.jsx)(n.h3,{id:"-signal-based-architecture",children:"\ud83d\udce1 Signal-based Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The store implementation uses these key concepts:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Signals"}),": Each property in your store is backed by a signal (a read/write pair of functions)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependency Tracking"}),": JODS automatically tracks which properties are accessed during a subscriber function"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fine-grained Notifications"}),": Updates only trigger for subscribers that depend on changed properties"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-benefits",children:"\ud83d\ude80 Benefits"}),"\n",(0,i.jsx)(n.p,{children:"This approach provides several advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Reduced Re-renders"}),": Components only re-render when data they actually use changes"]}),"\n",(0,i.jsxs)(n.li,{children:["\u26a1 ",(0,i.jsx)(n.strong,{children:"Better Performance"}),": Fewer wasted update cycles, especially in larger applications"]}),"\n",(0,i.jsxs)(n.li,{children:["\ud83e\ude84 ",(0,i.jsx)(n.strong,{children:"Automatic Optimization"}),": No manual selector functions needed - dependencies are tracked automatically"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-subscription-behavior",children:"\ud83d\udd04 Subscription Behavior"}),"\n",(0,i.jsx)(n.p,{children:"When you subscribe to a store, JODS uses an automatic dependency tracking mechanism:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"JODS runs your subscriber function once immediately to track which properties are accessed"}),"\n",(0,i.jsx)(n.li,{children:"It remembers which properties were accessed and only notifies the subscriber when those specific properties change"}),"\n",(0,i.jsx)(n.li,{children:"If your subscriber doesn't access any properties, it becomes a global subscriber that gets notified on any change"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"-dynamic-dependencies",children:"\ud83c\udfaf Dynamic Dependencies"}),"\n",(0,i.jsx)(n.p,{children:"Dependencies are re-tracked each time your subscriber function runs. This means if your subscriber accesses different properties based on the current state, JODS will update the tracked dependencies automatically."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// This subscriber\'s dependencies change based on the value of showDetails\nstore.subscribe((state) => {\n  console.log("Always shows:", state.title);\n\n  if (state.showDetails) {\n    console.log("Only when details shown:", state.description);\n  }\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-unsubscribe-behavior",children:"\ud83d\uddd1\ufe0f Unsubscribe Behavior"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"subscribe"})," method returns an unsubscribe function that you can call to stop receiving updates:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const unsubscribe = store.subscribe((state) => {\n  console.log("Count:", state.count);\n});\n\n// Later, when you want to stop receiving updates\nunsubscribe();\n'})}),"\n",(0,i.jsx)(n.p,{children:"When you call the unsubscribe function:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The subscriber is immediately removed from the notification list"}),"\n",(0,i.jsx)(n.li,{children:"All signal subscriptions associated with this subscriber are properly cleaned up"}),"\n",(0,i.jsx)(n.li,{children:"The subscriber will never be called again when properties change"}),"\n",(0,i.jsx)(n.li,{children:"Memory usage is optimized by removing all references to the subscriber"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This clean unsubscribe behavior ensures your application doesn't experience memory leaks or unexpected behavior when components are unmounted or subscriptions are no longer needed."}),"\n",(0,i.jsx)(n.h2,{id:"-examples",children:"\ud83d\udca1 Examples"}),"\n",(0,i.jsx)(n.h3,{id:"-basic-example",children:"\ud83d\udfe2 Basic Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'import { store } from "jods";\n\nconst appState = store({\n  user: { name: "Burt" },\n  theme: "light",\n  counter: 0,\n});\n\n// This subscriber only depends on counter\nappState.subscribe((state) => {\n  console.log("Counter:", state.counter);\n});\n\n// This subscriber only depends on theme\nappState.subscribe((state) => {\n  console.log("Theme:", state.theme);\n});\n\n// Updating counter only notifies the first subscriber\nappState.counter++;\n\n// Updating theme only notifies the second subscriber\nappState.theme = "dark";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-react-component-example",children:"\u269b\ufe0f React Component Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { store } from "jods";\nimport { useJods } from "jods/react";\n\n// Create a store with multiple sections\nconst appStore = store({\n  user: { name: "Burt", role: "admin" },\n  settings: { theme: "light", notifications: true },\n  todos: [{ text: "Buy milk", done: false }],\n});\n\n// UserProfile component only re-renders when user data changes\nfunction UserProfile() {\n  const state = useJods(appStore);\n  console.log("UserProfile render");\n\n  return <div>User: {state.user.name}</div>;\n}\n\n// SettingsPanel component only re-renders when settings change\nfunction SettingsPanel() {\n  const state = useJods(appStore);\n  console.log("SettingsPanel render");\n\n  return (\n    <div>\n      <div>Theme: {state.settings.theme}</div>\n      <button\n        onClick={() =>\n          (appStore.settings.theme =\n            state.settings.theme === "light" ? "dark" : "light")\n        }\n      >\n        Toggle Theme\n      </button>\n    </div>\n  );\n}\n\n// TodoList component only re-renders when todos change\nfunction TodoList() {\n  const state = useJods(appStore);\n  console.log("TodoList render");\n\n  return (\n    <div>\n      <h3>Todos:</h3>\n      <ul>\n        {state.todos.map((todo, i) => (\n          <li key={i}>{todo.text}</li>\n        ))}\n      </ul>\n      <button\n        onClick={() =>\n          appStore.todos.push({\n            text: "New todo",\n            done: false,\n          })\n        }\n      >\n        Add Todo\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-technical-implementation",children:"\ud83d\udee0\ufe0f Technical Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Under the hood, JODS implements this optimization using a combination of JavaScript's Proxy and a dependency tracking system:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"When a subscriber runs for the first time, JODS tracks which properties are accessed"}),"\n",(0,i.jsx)(n.li,{children:"These dependencies are stored in a map for that specific subscriber"}),"\n",(0,i.jsx)(n.li,{children:"When properties are updated, JODS only notifies subscribers that depend on those properties"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach is similar to the reactivity systems in modern frameworks like Vue 3 and SolidJS, but it's packaged in a framework-agnostic way that feels like working with plain JavaScript objects."}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-comparison-with-other-approaches",children:"\u2696\ufe0f Comparison with Other Approaches"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Approach"}),(0,i.jsx)(n.th,{children:"Update Strategy"}),(0,i.jsx)(n.th,{children:"Performance"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Redux"}),(0,i.jsx)(n.td,{children:"Notify all subscribers, components must use selectors"}),(0,i.jsx)(n.td,{children:"Requires manual optimization"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Zustand"}),(0,i.jsx)(n.td,{children:"Store-wide updates, selector functions needed"}),(0,i.jsx)(n.td,{children:"Requires manual optimization"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Signals (SolidJS, Preact)"}),(0,i.jsx)(n.td,{children:"Property-level granularity"}),(0,i.jsx)(n.td,{children:"Automatic fine-grained updates"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"JODS"}),(0,i.jsx)(n.td,{children:"Property-level granularity with automatic tracking"}),(0,i.jsx)(n.td,{children:"Automatic fine-grained updates"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"-best-practices",children:"\ud83d\udc4d Best Practices"}),"\n",(0,i.jsx)(n.p,{children:"To get the most out of JODS's fine-grained reactivity:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Keep subscriber functions focused"}),": Access only the properties you need"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Structure your state logically"}),": Group related data together"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use computed values"}),": These automatically track their dependencies too"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-deep-nesting-and-arrays",children:"\ud83c\udf33 Deep Nesting and Arrays"}),"\n",(0,i.jsx)(n.p,{children:"JODS's fine-grained tracking works with deeply nested properties and arrays. When you access a nested property or array element, JODS tracks that specific path as a dependency."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const store = createStore({\n  nested: {\n    deeply: {\n      value: 42,\n    },\n  },\n  items: [1, 2, 3],\n});\n\n// This only tracks nested.deeply.value as a dependency\nstore.subscribe((state) => console.log(state.nested.deeply.value));\n\n// This only tracks items as a dependency\nstore.subscribe((state) => console.log(state.items.length));\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);