"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6922],{2704:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"time-travel-debugging-old","title":"Time-Travel Debugging (Old Version)","description":"jods includes powerful time-travel debugging capabilities that allow you to track state changes over time and jump back to previous states. This feature is invaluable for debugging complex state changes and understanding how your application\'s state evolves.","source":"@site/docs/time-travel-debugging-old.md","sourceDirName":".","slug":"/time-travel-debugging-old","permalink":"/fr/time-travel-debugging-old","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/time-travel-debugging-old.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Time-Travel Debugging (Old Version)"},"sidebar":"jodsSidebar","previous":{"title":"\ud83d\udd70\ufe0f Time-Travel Debugging","permalink":"/fr/time-travel-debugging"},"next":{"title":"\ud83d\udcbe State Persistence","permalink":"/fr/state-persistence"}}');var s=t(3420),r=t(3774);const i={sidebar_position:6,title:"Time-Travel Debugging (Old Version)"},a="Time-Travel Debugging \ud83d\udd70\ufe0f \ud83d\udd04 \ud83d\udc3f\ufe0f",c={},d=[{value:"Basic Usage \ud83d\ude80",id:"basic-usage-",level:2},{value:"History API \ud83d\udcd6",id:"history-api-",level:2},{value:"<code>history(store, options?)</code> \ud83d\udd70\ufe0f",id:"historystore-options-\ufe0f",level:3},{value:"History Entries \ud83d\udcdd",id:"history-entries-",level:2},{value:"Branching History \ud83c\udf32",id:"branching-history-",level:2},{value:"React Integration \u269b\ufe0f",id:"react-integration-\ufe0f",level:2},{value:"Complete Example \ud83e\udd86",id:"complete-example-",level:2},{value:"Best Practices \u2705",id:"best-practices-",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"time-travel-debugging-\ufe0f--\ufe0f",children:"Time-Travel Debugging \ud83d\udd70\ufe0f \ud83d\udd04 \ud83d\udc3f\ufe0f"})}),"\n",(0,s.jsx)(n.p,{children:"jods includes powerful time-travel debugging capabilities that allow you to track state changes over time and jump back to previous states. This feature is invaluable for debugging complex state changes and understanding how your application's state evolves."}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage-",children:"Basic Usage \ud83d\ude80"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"history()"})," function creates a history tracker for a store, which records all state changes and provides methods to travel between them:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { store, history, json } from "jods";\n\n// Create a store\nconst counter = store({ count: 0 });\n\n// Create a history tracker\nconst counterHistory = history(counter);\n\n// Make some changes\ncounter.count = 1;\ncounter.count = 2;\ncounter.count = 3;\n\n// Time travel to first state\ncounterHistory.travelTo(0);\nconsole.log(json(counter)); // { count: 0 }\n\n// Move forward\ncounterHistory.forward();\nconsole.log(json(counter)); // { count: 1 }\n\n// Jump to latest state\ncounterHistory.travelTo(counterHistory.getEntries().length - 1);\nconsole.log(json(counter)); // { count: 3 }\n'})}),"\n",(0,s.jsx)(n.h2,{id:"history-api-",children:"History API \ud83d\udcd6"}),"\n",(0,s.jsxs)(n.h3,{id:"historystore-options-\ufe0f",children:[(0,s.jsx)(n.code,{children:"history(store, options?)"})," \ud83d\udd70\ufe0f"]}),"\n",(0,s.jsx)(n.p,{children:"Creates a history tracker for a store."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"store"}),": The store to track"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options"})," (optional): Configuration options","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxEntries"}),": Maximum number of history entries to keep (default: 50)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"active"}),": Whether history tracking is active (default: true in development, false in production)"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),": A History instance with the following methods:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"travelTo(index)"})," \ud83d\ude97: Travel to a specific point in history"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"back()"})," \u23ee\ufe0f: Go back one step in history"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"forward()"})," \u23ed\ufe0f: Go forward one step in history"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getEntries()"})," \ud83d\udccb: Get all history entries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getCurrentIndex()"})," \ud83d\udd0d: Get the current index in history"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"clear()"})," \ud83e\uddf9: Clear all history entries except the current one"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"destroy()"})," \ud83d\uddd1\ufe0f: Remove subscription to store updates"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"history-entries-",children:"History Entries \ud83d\udcdd"}),"\n",(0,s.jsx)(n.p,{children:"Each history entry contains:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"state"})," \ud83d\udce6: A snapshot of the entire store state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"timestamp"})," \u23f1\ufe0f: When the change occurred"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"diff"})," \ud83d\udd04: What changed from the previous state"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Example of accessing history entries\nconst entries = counterHistory.getEntries();\nentries.forEach((entry, index) => {\n  console.log(`Entry ${index}:`);\n  console.log(`State:`, entry.state);\n  console.log(`Time:`, new Date(entry.timestamp).toLocaleTimeString());\n  if (entry.diff) {\n    console.log(`Changes:`, entry.diff);\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"branching-history-",children:"Branching History \ud83c\udf32"}),"\n",(0,s.jsx)(n.p,{children:"When you travel back in time and then make changes, jods automatically creates a new branch of history, discarding future states that are no longer relevant:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Start with a simple counter\nconst counter = store({ count: 0 });\nconst counterHistory = history(counter);\n\n// Make some changes\ncounter.count = 10;\ncounter.count = 20;\ncounter.count = 30;\n\n// Go back to the first change\ncounterHistory.travelTo(1); // count is now 10\n\n// Make a new change - this creates a branch and discards future states\ncounter.count = 15;\n\n// History now contains: [0, 10, 15] instead of [0, 10, 20, 30]\nconsole.log(counterHistory.getEntries().map((entry) => entry.state.count));\n"})}),"\n",(0,s.jsx)(n.h2,{id:"react-integration-\ufe0f",children:"React Integration \u269b\ufe0f"}),"\n",(0,s.jsx)(n.p,{children:"For React applications, jods provides a debugger component that renders a UI for time-travel debugging:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { store } from "jods";\nimport { useJods, createDebugger } from "jods/react";\n\n// Create a store\nconst appStore = store({ count: 0 });\n\n// Create a debugger component\nconst AppDebugger = createDebugger(appStore, {\n  position: "bottom", // or \'right\'\n  showDiff: true,\n  maxEntries: 50,\n});\n\nfunction App() {\n  const state = useJods(appStore);\n\n  return (\n    <div>\n      <h1>Count: {state.count}</h1>\n      <button onClick={() => state.count++}>Increment</button>\n\n      {/* Add the debugger component (only included in development) */}\n      <AppDebugger />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The debugger component is development-only and doesn't add any overhead in production builds."}),"\n",(0,s.jsx)(n.h2,{id:"complete-example-",children:"Complete Example \ud83e\udd86"}),"\n",(0,s.jsx)(n.p,{children:"Here's a more complete example of using history for debugging:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { store, json, onUpdate, computed, history } from "jods";\n\n// Create a todo list store\nconst todos = store({\n  items: [],\n  filter: "all",\n});\n\n// Add a computed property\ntodos.activeCount = computed(\n  () => todos.items.filter((item) => !item.completed).length\n);\n\n// Create a history tracker\nconst todosHistory = history(todos);\n\n// Log changes as they happen\nonUpdate(todos, (state) => {\n  console.log("State updated:", json(state));\n});\n\n// Add some todos\nfunction addTodo(text) {\n  todos.items.push({\n    id: Date.now(),\n    text,\n    completed: false,\n  });\n}\n\naddTodo("Learn jods");\naddTodo("Build an app");\naddTodo("Master time travel");\n\n// Complete a todo\ntodos.items[1].completed = true;\n\n// Inspect history\nconsole.log(`History has ${todosHistory.getEntries().length} entries`);\n\n// Go back to before the second todo was added\ntodosHistory.travelTo(1);\nconsole.log("Traveled back:", json(todos));\n\n// Now add a different todo - this creates a new timeline\naddTodo("Alternative task");\nconsole.log("New branch:", json(todos));\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-",children:"Best Practices \u2705"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\ud83d\udd2c Only use history tracking in development or debugging scenarios"}),"\n",(0,s.jsxs)(n.li,{children:["\ud83d\udcca Set a reasonable ",(0,s.jsx)(n.code,{children:"maxEntries"})," value to prevent memory issues"]}),"\n",(0,s.jsxs)(n.li,{children:["\ud83e\uddf9 Call ",(0,s.jsx)(n.code,{children:"destroy()"})," when you're done with a history tracker to prevent memory leaks"]}),"\n",(0,s.jsxs)(n.li,{children:["\ud83d\udd0d Use the ",(0,s.jsx)(n.code,{children:"diff"})," property to understand what changed between states"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},3774:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(6672);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);