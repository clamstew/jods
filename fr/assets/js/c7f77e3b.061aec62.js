"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1727],{3774:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(6672);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}},8798:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"sync/api-reference","title":"API Reference","description":"Complete reference for the jods sync API","source":"@site/docs/sync/api-reference.md","sourceDirName":"sync","slug":"/sync/api-reference","permalink":"/jods/fr/sync/api-reference","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/sync/api-reference.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"API Reference","description":"Complete reference for the jods sync API"},"sidebar":"jodsSidebar","previous":{"title":"\ud83d\uddbc\ufe0f Framework Examples","permalink":"/jods/fr/sync/framework-examples"},"next":{"title":"\ud83d\udd0c Framework Integrations","permalink":"/jods/fr/guides/framework-integrations"}}');var r=s(3420),a=s(3774);const o={sidebar_position:2,title:"API Reference",description:"Complete reference for the jods sync API"},c="Sync API Reference",i={},l=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"API Signature",id:"api-signature",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Type Definitions",id:"type-definitions",level:2},{value:"SyncSocket",id:"syncsocket",level:3},{value:"SyncOptions",id:"syncoptions",level:3},{value:"SyncMessage",id:"syncmessage",level:3},{value:"Options Reference",id:"options-reference",level:2},{value:"Security Options",id:"security-options",level:3},{value:"<code>allowKeys</code>",id:"allowkeys",level:4},{value:"<code>allowPaths</code>",id:"allowpaths",level:4},{value:"<code>sensitiveKeys</code>",id:"sensitivekeys",level:4},{value:"<code>validateSchema</code>",id:"validateschema",level:4},{value:"Performance Options",id:"performance-options",level:3},{value:"<code>throttleMs</code>",id:"throttlems",level:4},{value:"<code>maxMessageSize</code>",id:"maxmessagesize",level:4},{value:"Event Handlers",id:"event-handlers",level:3},{value:"<code>onDiffSend</code>",id:"ondiffsend",level:4},{value:"<code>onPatchReceive</code>",id:"onpatchreceive",level:4},{value:"<code>onError</code>",id:"onerror",level:4},{value:"Special Options",id:"special-options",level:3},{value:"<code>prefix</code>",id:"prefix",level:4},{value:"<code>receiveOnly</code>",id:"receiveonly",level:4},{value:"<code>filter</code>",id:"filter",level:4},{value:"Example: Secure Chat Application",id:"example-secure-chat-application",level:2},{value:"Transport Adapters",id:"transport-adapters",level:2},{value:"Socket.io Adapter",id:"socketio-adapter",level:3},{value:"iframe postMessage Adapter",id:"iframe-postmessage-adapter",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sync-api-reference",children:"Sync API Reference"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"sync"})," API enables bidirectional state synchronization between jods stores over socket-like connections such as WebSockets, BroadcastChannel, or postMessage."]}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { store, sync } from "jods";\n\n// Create a store\nconst myStore = store({\n  count: 0,\n  text: "Hello World",\n  user: {\n    name: "User",\n    preferences: {\n      theme: "light",\n    },\n  },\n});\n\n// Connect to a WebSocket\nconst socket = new WebSocket("wss://example.com");\n\n// Start syncing store with the socket\nconst stopSync = sync(socket, myStore);\n\n// Later, to stop syncing\nstopSync();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"api-signature",children:"API Signature"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function sync<T extends StoreState>(\n  socket: SyncSocket,\n  store: T,\n  options?: SyncOptions<T>\n): () => void;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"socket"})," (",(0,r.jsx)(n.code,{children:"SyncSocket"}),"): A socket-like object with messaging capabilities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"store"})," (",(0,r.jsx)(n.code,{children:"T"}),"): A jods store created with the ",(0,r.jsx)(n.code,{children:"store"})," function"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"options"})," (",(0,r.jsx)(n.code,{children:"SyncOptions<T>"}),"): Optional configuration options"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),": A function that stops syncing and removes all listeners"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"type-definitions",children:"Type Definitions"}),"\n",(0,r.jsx)(n.h3,{id:"syncsocket",children:"SyncSocket"}),"\n",(0,r.jsx)(n.p,{children:"Any object that provides the following methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'interface SyncSocket {\n  // Send a message as a string\n  send: (msg: string) => void;\n\n  // Optional onmessage handler\n  onmessage?: ((event: { data: string }) => void) | null;\n\n  // Optional addEventListener/removeEventListener methods\n  addEventListener?: (\n    type: "message",\n    fn: (event: { data: string }) => void\n  ) => void;\n\n  removeEventListener?: (\n    type: "message",\n    fn: (event: { data: string }) => void\n  ) => void;\n\n  // Optional readyState property (like WebSocket)\n  readyState?: number;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This interface is compatible with:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"WebSocket"}),"\n",(0,r.jsx)(n.li,{children:"BroadcastChannel"}),"\n",(0,r.jsx)(n.li,{children:"Worker messaging"}),"\n",(0,r.jsx)(n.li,{children:"iframe postMessage (with an adapter)"}),"\n",(0,r.jsx)(n.li,{children:"Custom transport mechanisms"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"syncoptions",children:"SyncOptions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'interface SyncOptions<T extends StoreState> {\n  /**\n   * Number of milliseconds to wait before sending updates (throttling)\n   * @default 100\n   */\n  throttleMs?: number;\n\n  /**\n   * Prefix for message type, useful for multiplexing multiple stores on one socket\n   * @default "jods-sync"\n   */\n  prefix?: string;\n\n  /**\n   * Filter function to selectively sync parts of the store\n   * Return true to allow changes, false to block them\n   */\n  filter?: (changes: Changes<T>) => boolean;\n\n  /**\n   * Called when a diff is sent to the remote\n   */\n  onDiffSend?: (message: SyncMessage<T>) => void;\n\n  /**\n   * Called when a patch is received from the remote\n   * Return modified patch or null to prevent applying\n   */\n  onPatchReceive?: (message: SyncMessage<T>) => SyncMessage<T> | null;\n\n  /**\n   * Error handler for sync operations\n   */\n  onError?: (err: Error) => void;\n\n  /**\n   * Only receive updates, never send local changes\n   * @default false\n   */\n  receiveOnly?: boolean;\n\n  /**\n   * Array of top-level keys that are allowed to be synced (for security)\n   * If provided, only these properties will be synced\n   */\n  allowKeys?: Array<keyof T>;\n\n  /**\n   * Array of nested property paths that are allowed to be synced\n   * Examples: ["user.settings", "preferences.*"]\n   */\n  allowPaths?: string[];\n\n  /**\n   * Array of property paths that should never be synced\n   * Takes precedence over allowKeys and allowPaths\n   * Examples: ["user.apiKey", "secrets"]\n   */\n  sensitiveKeys?: string[];\n\n  /**\n   * Maximum size of messages in bytes\n   * @default 1048576 (1MB)\n   */\n  maxMessageSize?: number;\n\n  /**\n   * Schema to validate incoming patches\n   * Must have a parse() method (like Zod schemas)\n   */\n  validateSchema?: {\n    parse: (data: any) => any;\n  };\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"syncmessage",children:"SyncMessage"}),"\n",(0,r.jsx)(n.p,{children:"The message format used by the sync API:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SyncMessage<T extends StoreState> {\n  /** Unique ID for the client that sent the message */\n  clientId: string;\n\n  /** Changes to apply to the store */\n  changes: Changes<T>;\n\n  /** Optional message namespace/channel */\n  prefix?: string;\n\n  /** Optional timestamp for debugging */\n  timestamp?: number;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"options-reference",children:"Options Reference"}),"\n",(0,r.jsx)(n.h3,{id:"security-options",children:"Security Options"}),"\n",(0,r.jsx)(n.h4,{id:"allowkeys",children:(0,r.jsx)(n.code,{children:"allowKeys"})}),"\n",(0,r.jsx)(n.p,{children:"Limits which top-level properties can be synced:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Only sync these properties\nconst stopSync = sync(socket, store, {\n  allowKeys: ["messages", "users", "status"],\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"allowpaths",children:(0,r.jsx)(n.code,{children:"allowPaths"})}),"\n",(0,r.jsx)(n.p,{children:"Controls which nested properties can be synced:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Only sync these nested paths\nconst stopSync = sync(socket, store, {\n  allowPaths: [\n    "user.profile", // Allow all of user.profile\n    "settings.theme", // Allow only settings.theme\n    "messages.*", // Allow all properties under messages\n  ],\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"sensitivekeys",children:(0,r.jsx)(n.code,{children:"sensitiveKeys"})}),"\n",(0,r.jsx)(n.p,{children:"Prevents specific properties from being synced:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Never sync these properties, even if they\'re under allowKeys\nconst stopSync = sync(socket, store, {\n  allowKeys: ["user", "settings"],\n  sensitiveKeys: ["user.apiKey", "user.password", "settings.authToken"],\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"validateschema",children:(0,r.jsx)(n.code,{children:"validateSchema"})}),"\n",(0,r.jsx)(n.p,{children:"Validates incoming data against a schema:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { z } from \"zod\";\n// or import { j } from 'jods';\n\nconst schema = z.object({\n  messages: z.array(\n    z.object({\n      id: z.string(),\n      text: z.string(),\n      user: z.string(),\n    })\n  ),\n  users: z.array(\n    z.object({\n      id: z.string(),\n      name: z.string(),\n    })\n  ),\n});\n\nconst stopSync = sync(socket, store, {\n  validateSchema: schema,\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"performance-options",children:"Performance Options"}),"\n",(0,r.jsx)(n.h4,{id:"throttlems",children:(0,r.jsx)(n.code,{children:"throttleMs"})}),"\n",(0,r.jsx)(n.p,{children:"Controls how frequently updates are sent:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const stopSync = sync(socket, store, {\n  throttleMs: 300, // Send at most one update every 300ms\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"maxmessagesize",children:(0,r.jsx)(n.code,{children:"maxMessageSize"})}),"\n",(0,r.jsx)(n.p,{children:"Prevents transmitting excessively large messages:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const stopSync = sync(socket, store, {\n  maxMessageSize: 100 * 1024, // 100KB max\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"event-handlers",children:"Event Handlers"}),"\n",(0,r.jsx)(n.h4,{id:"ondiffsend",children:(0,r.jsx)(n.code,{children:"onDiffSend"})}),"\n",(0,r.jsx)(n.p,{children:"Called before sending changes to the remote:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const stopSync = sync(socket, store, {\n  onDiffSend: (message) => {\n    console.log("Sending changes:", message.changes);\n    // Optionally modify message\n  },\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"onpatchreceive",children:(0,r.jsx)(n.code,{children:"onPatchReceive"})}),"\n",(0,r.jsx)(n.p,{children:"Called when receiving changes, before applying them:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const stopSync = sync(socket, store, {\n  onPatchReceive: (message) => {\n    console.log("Received changes:", message.changes);\n\n    // Optionally modify the message\n    if (message.changes.count < 0) {\n      message.changes.count = 0; // Enforce non-negative count\n    }\n\n    return message; // Return modified message\n\n    // Or return null to prevent applying the changes\n    // if (hasInvalidData(message.changes)) return null;\n  },\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"onerror",children:(0,r.jsx)(n.code,{children:"onError"})}),"\n",(0,r.jsx)(n.p,{children:"Called when synchronization encounters an error:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const stopSync = sync(socket, store, {\n  onError: (error) => {\n    console.error("Sync error:", error);\n    store.status = "error";\n  },\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"special-options",children:"Special Options"}),"\n",(0,r.jsx)(n.h4,{id:"prefix",children:(0,r.jsx)(n.code,{children:"prefix"})}),"\n",(0,r.jsx)(n.p,{children:"Multiplexes multiple stores over the same socket:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Same socket, different prefixes\nconst stopUserSync = sync(socket, userStore, {\n  prefix: "users",\n});\n\nconst stopMessageSync = sync(socket, messageStore, {\n  prefix: "messages",\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"receiveonly",children:(0,r.jsx)(n.code,{children:"receiveOnly"})}),"\n",(0,r.jsx)(n.p,{children:"Creates a read-only sync that never sends changes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Only receive updates, never send\nconst stopSync = sync(socket, store, {\n  receiveOnly: true,\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"filter",children:(0,r.jsx)(n.code,{children:"filter"})}),"\n",(0,r.jsx)(n.p,{children:"Provides custom filtering logic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const stopSync = sync(socket, store, {\n  filter: (changes) => {\n    // Only sync if certain conditions are met\n    if (changes.hugeArray && changes.hugeArray.length > 1000) {\n      return false; // Don't sync huge arrays\n    }\n    return true; // Sync everything else\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"example-secure-chat-application",children:"Example: Secure Chat Application"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { store, sync } from "jods";\n\n// Create chat store\nconst chatStore = store({\n  messages: [],\n  users: [],\n  privateNotes: {}, // Should not be synced\n  authToken: "", // Should not be synced\n  status: "disconnected",\n});\n\n// Connect to chat server\nconst socket = new WebSocket("wss://chat.example.com");\n\n// Start secure sync\nconst stopSync = sync(socket, chatStore, {\n  // Only sync messages, users and status\n  allowKeys: ["messages", "users", "status"],\n\n  // Never sync these sensitive paths\n  sensitiveKeys: ["messages.*.privateFlag", "users.*.email"],\n\n  // Limit update frequency\n  throttleMs: 300,\n\n  // Handle connection errors\n  onError: (err) => {\n    console.error("Sync error:", err);\n    chatStore.status = "error";\n  },\n\n  // Filter outgoing messages\n  onDiffSend: (message) => {\n    // Log outgoing data\n    console.log("Syncing:", Object.keys(message.changes));\n  },\n\n  // Validate incoming data\n  onPatchReceive: (message) => {\n    // Sanitize incoming messages\n    if (message.changes.messages) {\n      message.changes.messages.forEach((msg) => {\n        // Remove any HTML to prevent XSS\n        if (msg.text) {\n          msg.text = msg.text.replace(/<[^>]*>/g, "");\n        }\n      });\n    }\n    return message;\n  },\n});\n\n// Update store - changes will be synced\nchatStore.status = "connected";\nchatStore.messages.push({\n  id: 1,\n  text: "Hello!",\n  timestamp: Date.now(),\n});\n\n// Won\'t be synced (not in allowKeys)\nchatStore.privateNotes = { todo: "Remember to buy milk" };\nchatStore.authToken = "jwt-token-123";\n\n// Clean up when done\nstopSync();\nsocket.close();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"transport-adapters",children:"Transport Adapters"}),"\n",(0,r.jsx)(n.h3,{id:"socketio-adapter",children:"Socket.io Adapter"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function createSocketIOAdapter(socket) {\n  return {\n    send: (message) => {\n      socket.emit("jods-sync", JSON.parse(message));\n    },\n    addEventListener: (type, listener) => {\n      if (type === "message") {\n        socket.on("jods-sync", (data) => {\n          listener({ data: JSON.stringify(data) });\n        });\n      }\n    },\n    removeEventListener: (type) => {\n      if (type === "message") {\n        socket.off("jods-sync");\n      }\n    },\n  };\n}\n\n// Usage\nimport io from "socket.io-client";\nconst socket = io("https://example.com");\nconst adapter = createSocketIOAdapter(socket);\nconst stopSync = sync(adapter, store);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"iframe-postmessage-adapter",children:"iframe postMessage Adapter"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function createIframeAdapter(iframe) {\n  const handler = (event) => {\n    if (\n      event.source === iframe.contentWindow &&\n      event.data &&\n      event.data.type === "jods-sync"\n    ) {\n      if (adapter.onmessage) {\n        adapter.onmessage({ data: JSON.stringify(event.data.payload) });\n      }\n\n      const listeners = adapter.eventListeners?.get("message") || [];\n      listeners.forEach((fn) =>\n        fn({ data: JSON.stringify(event.data.payload) })\n      );\n    }\n  };\n\n  window.addEventListener("message", handler);\n\n  const adapter = {\n    eventListeners: new Map([["message", []]]),\n    onmessage: null,\n\n    send: (message) => {\n      iframe.contentWindow.postMessage(\n        {\n          type: "jods-sync",\n          payload: JSON.parse(message),\n        },\n        "*"\n      );\n    },\n\n    addEventListener: (type, fn) => {\n      if (type === "message") {\n        if (!adapter.eventListeners.has(type)) {\n          adapter.eventListeners.set(type, []);\n        }\n        adapter.eventListeners.get(type).push(fn);\n      }\n    },\n\n    removeEventListener: (type, fn) => {\n      if (type === "message" && adapter.eventListeners.has(type)) {\n        const listeners = adapter.eventListeners.get(type);\n        const index = listeners.indexOf(fn);\n        if (index !== -1) {\n          listeners.splice(index, 1);\n        }\n      }\n    },\n\n    close: () => {\n      window.removeEventListener("message", handler);\n      adapter.eventListeners.clear();\n    },\n  };\n\n  return adapter;\n}\n\n// Usage\nconst iframe = document.getElementById("my-iframe");\nconst adapter = createIframeAdapter(iframe);\nconst stopSync = sync(adapter, store);\n'})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);