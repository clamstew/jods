"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1598],{2214:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"batch","title":"\ud83d\udd0b Batch Updates","description":"Batching allows you to group multiple state updates together, deferring notifications to subscribers until all changes are complete. This is especially useful for complex state transitions that should be treated as a single atomic update.","source":"@site/docs/batch.md","sourceDirName":".","slug":"/batch","permalink":"/batch","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/batch.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"jodsSidebar","previous":{"title":"\ud83e\uddec Fine-Grained Reactivity","permalink":"/fine-grained-reactivity"},"next":{"title":"\ud83d\udd0c Framework Integration","permalink":"/sync/framework-integration"}}');var s=n(3420),a=n(3774);const o={sidebar_position:5},i="\ud83d\udd0b Batch Updates",c={},l=[{value:"Why Use Batching?",id:"why-use-batching",level:2},{value:"\ud83e\uddf0 API Reference",id:"-api-reference",level:2},{value:"\ud83d\udce6 <code>store.batch(fn)</code>",id:"-storebatchfn",level:3},{value:"\ud83d\udce6 <code>store.beginBatch()</code> and <code>store.commitBatch()</code>",id:"-storebeginbatch-and-storecommitbatch",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 Move Batch Logic Outside Components",id:"-move-batch-logic-outside-components",level:3},{value:"\u2705 Use Custom Hooks for Batched Operations",id:"-use-custom-hooks-for-batched-operations",level:3},{value:"Examples",id:"examples",level:2},{value:"Complex Form Submission",id:"complex-form-submission",level:3},{value:"Multi-Step Process",id:"multi-step-process",level:3},{value:"Batching and Framework Integration",id:"batching-and-framework-integration",level:2},{value:"React Example",id:"react-example",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Error Handling in Batches",id:"error-handling-in-batches",level:3},{value:"Nested Batches",id:"nested-batches",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"-batch-updates",children:"\ud83d\udd0b Batch Updates"})}),"\n",(0,s.jsx)(t.p,{children:"Batching allows you to group multiple state updates together, deferring notifications to subscribers until all changes are complete. This is especially useful for complex state transitions that should be treated as a single atomic update."}),"\n",(0,s.jsx)(t.h2,{id:"why-use-batching",children:"Why Use Batching?"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Performance"}),": Prevents unnecessary re-renders by notifying subscribers only once"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Consistency"}),": Ensures computed values are only recalculated after all changes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Atomicity"}),": Updates multiple properties as a single transaction"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"-api-reference",children:"\ud83e\uddf0 API Reference"}),"\n",(0,s.jsxs)(t.h3,{id:"-storebatchfn",children:["\ud83d\udce6 ",(0,s.jsx)(t.code,{children:"store.batch(fn)"})]}),"\n",(0,s.jsx)(t.p,{children:"Executes a function that can make multiple store updates, batching them into a single notification."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Name"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"fn"})}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"Function"})}),(0,s.jsx)(t.td,{children:"A function containing multiple store updates to be batched"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"batchName"})}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"string?"})}),(0,s.jsx)(t.td,{children:"Optional name for debugging purposes (defaults to unnamed)"})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns:"})," The return value of the provided function"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'import { store } from "jods";\n\nconst userStore = store({\n  firstName: "John",\n  lastName: "Doe",\n  fullName: "", // Will be updated in batch\n  isActive: false,\n});\n\n// Multiple updates as a single batch\nuserStore.batch(() => {\n  userStore.firstName = "Jane";\n  userStore.lastName = "Smith";\n  userStore.fullName = "Jane Smith";\n  userStore.isActive = true;\n});\n'})}),"\n",(0,s.jsxs)(t.h3,{id:"-storebeginbatch-and-storecommitbatch",children:["\ud83d\udce6 ",(0,s.jsx)(t.code,{children:"store.beginBatch()"})," and ",(0,s.jsx)(t.code,{children:"store.commitBatch()"})]}),"\n",(0,s.jsx)(t.p,{children:"For manual control of batch operations when you need to start a batch and commit it later."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'import { store } from "jods";\n\nconst cartStore = store({\n  items: [],\n  total: 0,\n  itemCount: 0,\n});\n\n// Start batch manually\ncartStore.beginBatch();\n\n// Add multiple items (these don\'t trigger updates yet)\naddItemsToCart(items);\n\n// Update derived values\nupdateCartTotals();\n\n// Commit all changes as a single update\ncartStore.commitBatch();\n'})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(t.h3,{id:"-move-batch-logic-outside-components",children:"\u2705 Move Batch Logic Outside Components"}),"\n",(0,s.jsx)(t.p,{children:"Batching operations should generally live outside of UI components. This keeps component logic clean and focused on UI concerns, while store-related logic stays with the store."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Bad Pattern:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"function ProfileForm({ userData }) {\n  const handleSubmit = (e) => {\n    e.preventDefault();\n\n    // Batching inside component\n    userStore.batch(() => {\n      userStore.firstName = e.target.firstName.value;\n      userStore.lastName = e.target.lastName.value;\n      userStore.email = e.target.email.value;\n    });\n  };\n\n  return <form onSubmit={handleSubmit}>{/* form fields */}</form>;\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Good Pattern:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:'// userStore.js\nexport function updateUserProfile(userData) {\n  userStore.batch(() => {\n    userStore.firstName = userData.firstName;\n    userStore.lastName = userData.lastName;\n    userStore.email = userData.email;\n  });\n}\n\n// ProfileForm.jsx\nimport { updateUserProfile } from "./userStore";\n\nfunction ProfileForm() {\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    updateUserProfile({\n      firstName: e.target.firstName.value,\n      lastName: e.target.lastName.value,\n      email: e.target.email.value,\n    });\n  };\n\n  return <form onSubmit={handleSubmit}>{/* form fields */}</form>;\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"-use-custom-hooks-for-batched-operations",children:"\u2705 Use Custom Hooks for Batched Operations"}),"\n",(0,s.jsx)(t.p,{children:"Create custom hooks that encapsulate batched operations for reuse across components:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:'// useUserActions.js\nexport function useUserActions() {\n  return {\n    updateProfile: (userData) => {\n      userStore.batch(() => {\n        userStore.firstName = userData.firstName;\n        userStore.lastName = userData.lastName;\n        userStore.email = userData.email;\n      });\n    },\n\n    resetProfile: () => {\n      userStore.batch(() => {\n        userStore.firstName = "";\n        userStore.lastName = "";\n        userStore.email = "";\n      });\n    },\n  };\n}\n\n// Usage in component\nfunction ProfilePage() {\n  const { updateProfile, resetProfile } = useUserActions();\n  // Use these actions in event handlers\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(t.h3,{id:"complex-form-submission",children:"Complex Form Submission"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'// cartStore.js\nexport const cartStore = store({\n  items: [],\n  subtotal: 0,\n  tax: 0,\n  shipping: 0,\n  total: 0,\n});\n\nexport function updateCart(newItems) {\n  cartStore.batch(() => {\n    // Update items\n    cartStore.items = newItems;\n\n    // Calculate subtotal\n    cartStore.subtotal = newItems.reduce(\n      (sum, item) => sum + item.price * item.quantity,\n      0\n    );\n\n    // Calculate tax\n    cartStore.tax = cartStore.subtotal * 0.08;\n\n    // Calculate shipping (free if over $100)\n    cartStore.shipping = cartStore.subtotal > 100 ? 0 : 10;\n\n    // Calculate total\n    cartStore.total = cartStore.subtotal + cartStore.tax + cartStore.shipping;\n  });\n}\n\n// Usage\nupdateCart([\n  { id: 1, name: "Widget", price: 10, quantity: 2 },\n  { id: 2, name: "Gadget", price: 25, quantity: 1 },\n]);\n'})}),"\n",(0,s.jsx)(t.h3,{id:"multi-step-process",children:"Multi-Step Process"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'// orderStore.js\nexport const orderStore = store({\n  status: "idle",\n  currentStep: 0,\n  steps: ["cart", "shipping", "payment", "confirmation"],\n  shipping: {},\n  payment: {},\n  errors: {},\n});\n\nexport function advanceToNextStep(stepData) {\n  orderStore.batch(() => {\n    // Save current step data\n    const currentStepName = orderStore.steps[orderStore.currentStep];\n    orderStore[currentStepName] = stepData;\n\n    // Clear any previous errors\n    orderStore.errors = {};\n\n    // Update status\n    orderStore.status = "advancing";\n\n    // Move to next step\n    orderStore.currentStep += 1;\n\n    // If we\'ve reached the end, complete the order\n    if (orderStore.currentStep >= orderStore.steps.length) {\n      orderStore.status = "complete";\n    }\n  });\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"batching-and-framework-integration",children:"Batching and Framework Integration"}),"\n",(0,s.jsx)(t.p,{children:"When using jods with frameworks like React or Preact, the framework's own batching mechanisms work alongside jods batching."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"React/Preact"}),": These frameworks already batch state updates within event handlers. jods batching complements this by ensuring all store updates are treated as a single change."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Framework Updates vs. Store Updates"}),": Framework batching is about reducing renders, while jods batching is about ensuring store consistency and optimizing subscriber notifications."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"react-example",children:"React Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:'import { store } from "jods";\nimport { useStore } from "jods/react";\n\n// Store with actions\nconst todoStore = store({\n  todos: [],\n  filter: "all",\n  loading: false,\n});\n\n// Actions that use batching\nexport function addTodo(text) {\n  todoStore.batch(() => {\n    todoStore.loading = true;\n    todoStore.todos = [\n      ...todoStore.todos,\n      { id: Date.now(), text, completed: false },\n    ];\n    todoStore.loading = false;\n  });\n}\n\nexport function toggleTodo(id) {\n  todoStore.batch(() => {\n    todoStore.todos = todoStore.todos.map((todo) =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    );\n  });\n}\n\n// Component using actions\nfunction TodoApp() {\n  const { todos, filter, loading } = useStore(todoStore);\n\n  const handleAddTodo = (text) => {\n    addTodo(text); // Uses batching\n  };\n\n  return (\n    <div>\n      <TodoInput onAdd={handleAddTodo} disabled={loading} />\n      <TodoList todos={todos} onToggle={toggleTodo} />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,s.jsx)(t.h3,{id:"error-handling-in-batches",children:"Error Handling in Batches"}),"\n",(0,s.jsx)(t.p,{children:"Batches automatically clean up if an error occurs during execution, and will apply any changes that happened before the error:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'try {\n  userStore.batch(() => {\n    userStore.name = "New Name"; // This update will be applied\n    throw new Error("Something went wrong");\n    userStore.email = "new@example.com"; // This won\'t be reached\n  });\n} catch (error) {\n  console.error("Error during batch update:", error);\n  // Store will have name="New Name" but email won\'t be changed\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"nested-batches",children:"Nested Batches"}),"\n",(0,s.jsx)(t.p,{children:"Batches can be nested, with changes from inner batches being collected in the parent batch:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'userStore.batch(() => {\n  userStore.firstName = "Jane";\n\n  // Nested batch\n  userStore.batch(() => {\n    userStore.lastName = "Smith";\n    userStore.role = "Admin";\n  });\n\n  userStore.isActive = true;\n});\n// All four properties are updated in a single batch\n'})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3774:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var r=n(6672);const s={},a=r.createContext(s);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);