"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6910],{3774:(n,e,t)=>{t.d(e,{R:()=>c,x:()=>a});var s=t(6672);const o={},r=s.createContext(o);function c(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:c(n.components),s.createElement(r.Provider,{value:e},n.children)}},9284:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sync/framework-integration","title":"Framework Integration","description":"The sync API is designed to work seamlessly with all jods framework integrations. This page shows how to integrate the sync API with React, Preact, and Remix frameworks.","source":"@site/docs/sync/framework-integration.md","sourceDirName":"sync","slug":"/sync/framework-integration","permalink":"/jods/sync/framework-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/sync/framework-integration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"jodsSidebar","previous":{"title":"\ud83d\udd0b Batch Updates","permalink":"/jods/batch"},"next":{"title":"\ud83d\udee0\ufe0f Framework Usage","permalink":"/jods/sync/framework-usage"}}');var o=t(3420),r=t(3774);const c={},a="Framework Integration",i={},d=[{value:"React Integration",id:"react-integration",level:2},{value:"Basic Component-level Integration",id:"basic-component-level-integration",level:3},{value:"Custom Hook Pattern",id:"custom-hook-pattern",level:3},{value:"Cross-Tab Synchronization",id:"cross-tab-synchronization",level:3},{value:"Preact Integration",id:"preact-integration",level:2},{value:"Basic Component Example",id:"basic-component-example",level:3},{value:"Custom Hook for Preact",id:"custom-hook-for-preact",level:3},{value:"Remix Integration",id:"remix-integration",level:2},{value:"Basic Remix Integration",id:"basic-remix-integration",level:3},{value:"Integration with Remix Form Actions",id:"integration-with-remix-form-actions",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Connection Management",id:"connection-management",level:3},{value:"Security Best Practices",id:"security-best-practices",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Framework-Specific Recommendations",id:"framework-specific-recommendations",level:3},{value:"Debugging Tips",id:"debugging-tips",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"framework-integration",children:"Framework Integration"})}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"sync"})," API is designed to work seamlessly with all jods framework integrations. This page shows how to integrate the sync API with React, Preact, and Remix frameworks."]}),"\n",(0,o.jsx)(e.h2,{id:"react-integration",children:"React Integration"}),"\n",(0,o.jsx)(e.h3,{id:"basic-component-level-integration",children:"Basic Component-level Integration"}),"\n",(0,o.jsx)(e.p,{children:"In a React application, you typically want to set up the sync connection when your component mounts and clean it up when it unmounts:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:'import React, { useEffect, useState } from "react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/react";\n\n// Create your store\nconst counterStore = store({\n  count: 0,\n  user: {\n    name: "User",\n    status: "online",\n  },\n});\n\nfunction Counter() {\n  const state = useJods(counterStore);\n  const [syncActive, setSyncActive] = useState(false);\n  const [socket, setSocket] = useState(null);\n\n  // Set up WebSocket and sync on mount\n  useEffect(() => {\n    // Create WebSocket connection\n    const ws = new WebSocket("wss://yourapidomain.com/counters");\n\n    // Wait for connection to open\n    ws.addEventListener("open", () => {\n      // Set up sync and get cleanup function\n      const stopSync = sync(ws, counterStore, {\n        // Only sync the count, not user information\n        allowKeys: ["count"],\n        // Throttle updates to reduce network traffic\n        throttleMs: 300,\n      });\n\n      // Store socket for later and mark sync as active\n      setSocket(ws);\n      setSyncActive(true);\n\n      // Return cleanup function for useEffect\n      return () => {\n        stopSync();\n        ws.close();\n        setSyncActive(false);\n      };\n    });\n\n    // Handle socket closure\n    ws.addEventListener("close", () => {\n      setSyncActive(false);\n    });\n\n    // Clean up on unmount\n    return () => {\n      if (ws) ws.close();\n    };\n  }, []);\n\n  return (\n    <div>\n      <div>{syncActive ? "Connected" : "Disconnected"}</div>\n      <h1>Count: {state.count}</h1>\n      <button onClick={() => counterStore.count++}>Increment</button>\n      <p>\n        User: {state.user.name} ({state.user.status})\n      </p>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"custom-hook-pattern",children:"Custom Hook Pattern"}),"\n",(0,o.jsx)(e.p,{children:"For reusable sync functionality across components, create a custom hook:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:'import { useEffect, useState } from "react";\nimport { sync, Store } from "jods";\nimport { useJods } from "jods/react";\n\n// Custom hook for syncing a store with a WebSocket\nfunction useSyncedStore<T>(store: T & Store<T>, url: string, options = {}) {\n  const storeValue = useJods(store);\n  const [isConnected, setIsConnected] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    let stopSync: (() => void) | null = null;\n    const socket = new WebSocket(url);\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, store, {\n        ...options,\n        onError: (err) => {\n          setError(err);\n          if (options.onError) options.onError(err);\n        },\n      });\n      setIsConnected(true);\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    socket.addEventListener("error", (event) => {\n      setError(new Error("WebSocket error"));\n      setIsConnected(false);\n    });\n\n    return () => {\n      if (stopSync) stopSync();\n      socket.close();\n    };\n  }, [store, url, options]);\n\n  return { value: storeValue, isConnected, error };\n}\n\n// Usage in component\nfunction ChatApp() {\n  const chatStore = store({\n    messages: [],\n    activeUsers: [],\n  });\n\n  const { value, isConnected } = useSyncedStore(\n    chatStore,\n    "wss://example.com/chat",\n    { allowKeys: ["messages", "activeUsers"] }\n  );\n\n  return (\n    <div>\n      <div className={isConnected ? "status-connected" : "status-disconnected"}>\n        {isConnected ? "Connected" : "Disconnected"}\n      </div>\n\n      <ul>\n        {value.messages.map((msg, i) => (\n          <li key={i}>{msg.text}</li>\n        ))}\n      </ul>\n\n      <div>\n        <h3>Active Users ({value.activeUsers.length})</h3>\n        <ul>\n          {value.activeUsers.map((user) => (\n            <li key={user.id}>{user.name}</li>\n          ))}\n        </ul>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"cross-tab-synchronization",children:"Cross-Tab Synchronization"}),"\n",(0,o.jsx)(e.p,{children:"Sync state across multiple tabs in the same browser using BroadcastChannel:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:'import { useEffect } from "react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/react";\n\n// Create a store with initial data\nconst appStore = store({\n  theme: "light",\n  sidebarOpen: true,\n  notifications: [],\n});\n\nfunction AppSettings() {\n  const state = useJods(appStore);\n\n  // Set up cross-tab sync on mount\n  useEffect(() => {\n    // Create a channel with a unique name for your app\n    const channel = new BroadcastChannel("app-state-sync");\n\n    // Start syncing\n    const stopSync = sync(channel, appStore);\n\n    // Clean up on unmount\n    return () => {\n      stopSync();\n      channel.close();\n    };\n  }, []);\n\n  return (\n    <div>\n      <h1>Settings</h1>\n      <div>\n        <label>\n          Theme:\n          <select\n            value={state.theme}\n            onChange={(e) => {\n              appStore.theme = e.target.value;\n            }}\n          >\n            <option value="light">Light</option>\n            <option value="dark">Dark</option>\n            <option value="system">System</option>\n          </select>\n        </label>\n      </div>\n\n      <button onClick={() => (appStore.sidebarOpen = !state.sidebarOpen)}>\n        {state.sidebarOpen ? "Hide" : "Show"} Sidebar\n      </button>\n\n      <div>\n        <h3>Notifications ({state.notifications.length})</h3>\n        <button\n          onClick={() => {\n            appStore.notifications.push({\n              id: Date.now(),\n              text: "New notification at " + new Date().toLocaleTimeString(),\n            });\n          }}\n        >\n          Add Notification\n        </button>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"preact-integration",children:"Preact Integration"}),"\n",(0,o.jsx)(e.p,{children:"The Preact integration follows the same patterns as React but uses Preact's hooks and components."}),"\n",(0,o.jsx)(e.h3,{id:"basic-component-example",children:"Basic Component Example"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:'import { h } from "preact";\nimport { useEffect, useState } from "preact/hooks";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/preact";\n\n// Create store\nconst taskStore = store({\n  tasks: [],\n  filter: "all",\n});\n\nfunction TaskList() {\n  const state = useJods(taskStore);\n  const [isConnected, setIsConnected] = useState(false);\n\n  // Set up sync on mount\n  useEffect(() => {\n    const socket = new WebSocket("wss://tasks-api.example.com");\n\n    socket.addEventListener("open", () => {\n      const stopSync = sync(socket, taskStore);\n      setIsConnected(true);\n\n      return () => {\n        stopSync();\n        setIsConnected(false);\n      };\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    return () => {\n      socket.close();\n    };\n  }, []);\n\n  // Filter tasks based on the current filter\n  const filteredTasks = state.tasks.filter((task) => {\n    if (state.filter === "all") return true;\n    if (state.filter === "active") return !task.completed;\n    if (state.filter === "completed") return task.completed;\n    return true;\n  });\n\n  return (\n    <div>\n      <div class={isConnected ? "connected" : "disconnected"}>\n        {isConnected ? "Connected" : "Disconnected"}\n      </div>\n\n      <h1>Tasks</h1>\n\n      <div class="filters">\n        <button\n          class={state.filter === "all" ? "active" : ""}\n          onClick={() => (taskStore.filter = "all")}\n        >\n          All\n        </button>\n        <button\n          class={state.filter === "active" ? "active" : ""}\n          onClick={() => (taskStore.filter = "active")}\n        >\n          Active\n        </button>\n        <button\n          class={state.filter === "completed" ? "active" : ""}\n          onClick={() => (taskStore.filter = "completed")}\n        >\n          Completed\n        </button>\n      </div>\n\n      <ul class="task-list">\n        {filteredTasks.map((task) => (\n          <li key={task.id} class={task.completed ? "completed" : ""}>\n            <input\n              type="checkbox"\n              checked={task.completed}\n              onChange={() => {\n                const t = taskStore.tasks.find((t) => t.id === task.id);\n                if (t) t.completed = !t.completed;\n              }}\n            />\n            <span>{task.text}</span>\n          </li>\n        ))}\n      </ul>\n\n      <form\n        onSubmit={(e) => {\n          e.preventDefault();\n          const input = e.currentTarget.elements.namedItem(\n            "task"\n          ) as HTMLInputElement;\n          if (input?.value) {\n            taskStore.tasks.push({\n              id: Date.now().toString(),\n              text: input.value,\n              completed: false,\n            });\n            input.value = "";\n          }\n        }}\n      >\n        <input name="task" placeholder="Add a task" />\n        <button type="submit">Add</button>\n      </form>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"custom-hook-for-preact",children:"Custom Hook for Preact"}),"\n",(0,o.jsx)(e.p,{children:"Similar to the React custom hook, but using Preact's hooks:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:'import { useEffect, useState } from "preact/hooks";\nimport { sync, Store } from "jods";\nimport { useJods } from "jods/preact";\n\n// Custom hook for syncing a store with a WebSocket in Preact\nfunction useSyncedStore<T>(store: T & Store<T>, url: string, options = {}) {\n  const storeValue = useJods(store);\n  const [isConnected, setIsConnected] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    let stopSync: (() => void) | null = null;\n    const socket = new WebSocket(url);\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, store, {\n        ...options,\n        onError: (err) => {\n          setError(err);\n          if (options.onError) options.onError(err);\n        },\n      });\n      setIsConnected(true);\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    socket.addEventListener("error", (event) => {\n      setError(new Error("WebSocket error"));\n      setIsConnected(false);\n    });\n\n    return () => {\n      if (stopSync) stopSync();\n      socket.close();\n    };\n  }, [store, url, options]);\n\n  return { value: storeValue, isConnected, error };\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"remix-integration",children:"Remix Integration"}),"\n",(0,o.jsx)(e.p,{children:"Remix requires special handling due to its server-side rendering (SSR) and hydration process. The key is to only enable sync after hydration is complete."}),"\n",(0,o.jsx)(e.h3,{id:"basic-remix-integration",children:"Basic Remix Integration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:'import { useEffect, useState } from "react";\nimport { json } from "@remix-run/node";\nimport { useLoaderData } from "@remix-run/react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/remix";\n\n// Server-side loader\nexport async function loader() {\n  // Fetch initial data from API/database\n  const todos = await fetchTodosFromDatabase();\n\n  return json({ todos });\n}\n\n// Client store - create outside component\nconst todoStore = store({\n  todos: [],\n  filter: "all",\n});\n\nexport default function TodoApp() {\n  // Get initial data from loader\n  const initialData = useLoaderData();\n\n  // Track hydration status\n  const [isHydrated, setIsHydrated] = useState(false);\n\n  // Track sync status\n  const [isConnected, setIsConnected] = useState(false);\n\n  // Use the store with Remix\'s useJods hook\n  const state = useJods(todoStore);\n\n  // Initialize store with server data on mount\n  useEffect(() => {\n    // Only do this once on initial load\n    if (!isHydrated) {\n      // Populate store with server data\n      todoStore.todos = initialData.todos;\n      todoStore.filter = "all";\n\n      // Mark as hydrated\n      setIsHydrated(true);\n    }\n  }, [initialData]);\n\n  // ONLY set up sync AFTER hydration is complete\n  useEffect(() => {\n    // Skip if not hydrated yet\n    if (!isHydrated) return;\n\n    // Now it\'s safe to set up WebSocket and sync\n    const socket = new WebSocket("wss://remix-todos-api.example.com");\n\n    socket.addEventListener("open", () => {\n      const stopSync = sync(socket, todoStore, {\n        // Sync options here\n        throttleMs: 100,\n      });\n\n      setIsConnected(true);\n\n      return () => {\n        stopSync();\n        socket.close();\n        setIsConnected(false);\n      };\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    return () => {\n      socket.close();\n    };\n  }, [isHydrated]); // Only run when hydration state changes\n\n  return (\n    <div>\n      <div className="status">\n        {!isHydrated\n          ? "Hydrating..."\n          : isConnected\n          ? "Connected"\n          : "Disconnected"}\n      </div>\n\n      <h1>Todo List</h1>\n\n      <ul>\n        {state.todos.map((todo) => (\n          <li key={todo.id}>\n            <input\n              type="checkbox"\n              checked={todo.completed}\n              onChange={() => {\n                const t = todoStore.todos.find((t) => t.id === todo.id);\n                if (t) t.completed = !t.completed;\n              }}\n            />\n            <span>{todo.text}</span>\n          </li>\n        ))}\n      </ul>\n\n      {/* Form to add todos */}\n      <form\n        method="post"\n        onSubmit={(e) => {\n          e.preventDefault();\n          const formData = new FormData(e.currentTarget);\n          const text = formData.get("text") as string;\n\n          // Update local store\n          todoStore.todos.push({\n            id: Date.now().toString(),\n            text,\n            completed: false,\n          });\n\n          // Reset form\n          e.currentTarget.reset();\n        }}\n      >\n        <input name="text" placeholder="What needs to be done?" />\n        <button type="submit">Add Todo</button>\n      </form>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"integration-with-remix-form-actions",children:"Integration with Remix Form Actions"}),"\n",(0,o.jsx)(e.p,{children:"For a more complete Remix integration with form actions:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:'import { useEffect, useState } from "react";\nimport { json, redirect } from "@remix-run/node";\nimport { useLoaderData, useActionData, Form } from "@remix-run/react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/remix";\n\n// Server-side loader\nexport async function loader() {\n  // Fetch todos from database\n  const todos = await fetchTodosFromDatabase();\n\n  return json({ todos });\n}\n\n// Server-side action handler\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const intent = formData.get("intent");\n\n  if (intent === "add-todo") {\n    const text = formData.get("text");\n\n    // Create in database\n    const newTodo = await createTodoInDatabase({\n      text,\n      completed: false,\n    });\n\n    return json({ success: true, todo: newTodo });\n  }\n\n  if (intent === "toggle-todo") {\n    const id = formData.get("id");\n    const completed = formData.get("completed") === "true";\n\n    // Update in database\n    await updateTodoInDatabase(id, { completed: !completed });\n\n    return json({ success: true });\n  }\n\n  return json({ success: false, error: "Unknown intent" });\n}\n\n// Client store\nconst todoStore = store({\n  todos: [],\n  filter: "all",\n});\n\nexport default function TodoApp() {\n  const loaderData = useLoaderData();\n  const actionData = useActionData();\n\n  const [isHydrated, setIsHydrated] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n\n  // Use the store with Remix\'s useJods hook\n  const state = useJods(todoStore);\n\n  // Initialize store with server data on mount\n  useEffect(() => {\n    if (!isHydrated) {\n      todoStore.todos = loaderData.todos;\n      setIsHydrated(true);\n    }\n  }, [loaderData]);\n\n  // Handle action data updates\n  useEffect(() => {\n    if (actionData?.success && actionData?.todo) {\n      // Check if todo already exists (to avoid duplicates from sync)\n      const exists = todoStore.todos.some((t) => t.id === actionData.todo.id);\n\n      if (!exists) {\n        todoStore.todos.push(actionData.todo);\n      }\n    }\n  }, [actionData]);\n\n  // Set up sync AFTER hydration\n  useEffect(() => {\n    if (!isHydrated) return;\n\n    const socket = new WebSocket("wss://remix-todos-api.example.com");\n\n    socket.addEventListener("open", () => {\n      const stopSync = sync(socket, todoStore);\n      setIsConnected(true);\n\n      return () => {\n        stopSync();\n        socket.close();\n        setIsConnected(false);\n      };\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    return () => {\n      socket.close();\n    };\n  }, [isHydrated]);\n\n  return (\n    <div>\n      <div className="status">\n        {!isHydrated\n          ? "Hydrating..."\n          : isConnected\n          ? "Connected"\n          : "Disconnected"}\n      </div>\n\n      <h1>Todo List</h1>\n\n      <ul>\n        {state.todos.map((todo) => (\n          <li key={todo.id}>\n            <Form method="post" className="inline-form">\n              <input type="hidden" name="intent" value="toggle-todo" />\n              <input type="hidden" name="id" value={todo.id} />\n              <input\n                type="hidden"\n                name="completed"\n                value={String(todo.completed)}\n              />\n              <button\n                type="submit"\n                className={todo.completed ? "completed" : ""}\n                onClick={(e) => {\n                  // Optimistic UI update\n                  e.preventDefault();\n\n                  // Update local state immediately\n                  const t = todoStore.todos.find((t) => t.id === todo.id);\n                  if (t) t.completed = !t.completed;\n\n                  // Then submit the form programmatically\n                  e.currentTarget.form.submit();\n                }}\n              >\n                {todo.completed ? "\u2713" : "\u25cb"}\n              </button>\n            </Form>\n            <span>{todo.text}</span>\n          </li>\n        ))}\n      </ul>\n\n      <Form method="post" className="add-form">\n        <input type="hidden" name="intent" value="add-todo" />\n        <input name="text" placeholder="What needs to be done?" required />\n        <button type="submit">Add Todo</button>\n      </Form>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"connection-management",children:"Connection Management"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Always clean up connections"})," when components unmount:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"useEffect(() => {\n  const socket = new WebSocket(url);\n  const stopSync = sync(socket, store);\n\n  return () => {\n    stopSync(); // First stop syncing\n    socket.close(); // Then close the socket\n  };\n}, []);\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Handle connection errors and reconnection"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'useEffect(() => {\n  let socket = null;\n  let stopSync = null;\n  let reconnectTimer = null;\n\n  const connect = () => {\n    socket = new WebSocket(url);\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, store);\n      setIsConnected(true);\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n      // Try to reconnect after 3 seconds\n      reconnectTimer = setTimeout(connect, 3000);\n    });\n\n    socket.addEventListener("error", () => {\n      socket.close();\n    });\n  };\n\n  connect();\n\n  return () => {\n    if (stopSync) stopSync();\n    if (socket) socket.close();\n    if (reconnectTimer) clearTimeout(reconnectTimer);\n  };\n}, [url]);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Only sync necessary data"})," using the ",(0,o.jsx)(e.code,{children:"allowKeys"})," option:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'const stopSync = sync(socket, userStore, {\n  // Only sync these properties\n  allowKeys: ["preferences", "publicProfile"],\n  // Never sync sensitive properties\n  sensitiveKeys: ["password", "authTokens", "personalData.ssn"],\n});\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsxs)(e.strong,{children:["Use ",(0,o.jsx)(e.code,{children:"receiveOnly"})," mode"]})," for untrusted sources:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// For public displays that should never send data back\nconst stopSync = sync(publicSocket, displayStore, {\n  receiveOnly: true,\n});\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Validate incoming data"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'const stopSync = sync(socket, store, {\n  validateSchema: (changes) => {\n    // Use Zod, Yup, or custom validation\n    try {\n      mySchema.parse(changes);\n      return true;\n    } catch (error) {\n      console.error("Invalid data received:", error);\n      return false;\n    }\n  },\n});\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Adjust throttling"})," based on your application's needs:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// For real-time collaborative editing, use low throttle\nconst stopSync = sync(socket, documentStore, {\n  throttleMs: 50, // Send updates quickly\n});\n\n// For less critical updates, use higher throttle\nconst stopSync = sync(socket, analyticsStore, {\n  throttleMs: 1000, // Only send every second\n});\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Filter unnecessary changes"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'const stopSync = sync(socket, store, {\n  filter: (changes) => {\n    // Only sync if changes are significant\n    return Object.keys(changes).some(\n      (key) =>\n        key === "important" ||\n        (changes[key] &&\n          typeof changes[key] === "object" &&\n          Object.keys(changes[key]).length > 0)\n    );\n  },\n});\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"framework-specific-recommendations",children:"Framework-Specific Recommendations"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"For React/Preact"}),": Create reusable custom hooks for sync functionality."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"For Remix"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Always wait for hydration to complete before enabling sync"}),"\n",(0,o.jsx)(e.li,{children:"Coordinate with form submissions to avoid duplicate updates"}),"\n",(0,o.jsx)(e.li,{children:"Consider optimistic UI updates for better UX"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"For all frameworks"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Keep socket and sync logic in top-level components"}),"\n",(0,o.jsx)(e.li,{children:"Use connection status for visual feedback to users"}),"\n",(0,o.jsx)(e.li,{children:"Implement proper error handling and reconnection logic"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"debugging-tips",children:"Debugging Tips"}),"\n",(0,o.jsxs)(e.p,{children:["To help debug sync issues, use the ",(0,o.jsx)(e.code,{children:"onDiffSend"})," and ",(0,o.jsx)(e.code,{children:"onPatchReceive"})," callbacks:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'const stopSync = sync(socket, store, {\n  onDiffSend: (message) => {\n    console.log("Sending:", message);\n  },\n  onPatchReceive: (message) => {\n    console.log("Received:", message);\n  },\n  onError: (error) => {\n    console.error("Sync error:", error);\n  },\n});\n'})}),"\n",(0,o.jsx)(e.p,{children:"For more advanced debugging, enable jods debug logging:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'import { debug } from "jods";\n\n// Enable debug logging for sync operations\ndebug.configure({\n  enabled: true,\n  categories: ["sync"],\n});\n'})}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Check the ",(0,o.jsx)(e.a,{href:"/jods/sync/api-reference",children:"Sync API Reference"})," for all available options"]}),"\n",(0,o.jsxs)(e.li,{children:["See ",(0,o.jsx)(e.a,{href:"./socket-adapters.md",children:"Socket Adapters"})," for integrating with different transport libraries"]}),"\n",(0,o.jsxs)(e.li,{children:["Learn about ",(0,o.jsx)(e.a,{href:"./security.md",children:"Security Best Practices"})," when using sync with remote servers"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}}}]);