"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[994],{3774:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6672);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},7008:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sync/framework-examples","title":"Framework Integration Examples","description":"This page provides practical, ready-to-use examples of the sync API with different frameworks. Each example demonstrates a common use case that you can adapt for your own applications.","source":"@site/docs/sync/framework-examples.md","sourceDirName":"sync","slug":"/sync/framework-examples","permalink":"/sync/framework-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/sync/framework-examples.md","tags":[],"version":"current","frontMatter":{},"sidebar":"jodsSidebar","previous":{"title":"\ud83d\udee0\ufe0f Framework Usage","permalink":"/sync/framework-usage"},"next":{"title":"\ud83d\udcda API Reference","permalink":"/sync/api-reference"}}');var a=t(3420),o=t(3774);const r={},i="Framework Integration Examples",c={},d=[{value:"React Examples",id:"react-examples",level:2},{value:"Real-time Chat Application",id:"real-time-chat-application",level:3},{value:"Collaborative Todo Application with Real-time Updates",id:"collaborative-todo-application-with-real-time-updates",level:3},{value:"Preact Examples",id:"preact-examples",level:2},{value:"Cross-Tab Synchronization with BroadcastChannel",id:"cross-tab-synchronization-with-broadcastchannel",level:3},{value:"Real-time Kanban Board",id:"real-time-kanban-board",level:3},{value:"Remix Examples",id:"remix-examples",level:2},{value:"Collaborative Document Editor with Server Persistence",id:"collaborative-document-editor-with-server-persistence",level:3},{value:"Real-time Dashboard with Server-Sent Events and WebSockets",id:"real-time-dashboard-with-server-sent-events-and-websockets",level:3},{value:"Customizing Sync Behavior",id:"customizing-sync-behavior",level:2},{value:"Security and Selective Syncing",id:"security-and-selective-syncing",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Custom Transformations",id:"custom-transformations",level:3},{value:"Debugging and Monitoring",id:"debugging-and-monitoring",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"framework-integration-examples",children:"Framework Integration Examples"})}),"\n",(0,a.jsxs)(n.p,{children:["This page provides practical, ready-to-use examples of the ",(0,a.jsx)(n.code,{children:"sync"})," API with different frameworks. Each example demonstrates a common use case that you can adapt for your own applications."]}),"\n",(0,a.jsx)(n.h2,{id:"react-examples",children:"React Examples"}),"\n",(0,a.jsx)(n.h3,{id:"real-time-chat-application",children:"Real-time Chat Application"}),"\n",(0,a.jsxs)(n.p,{children:["This example shows how to build a simple real-time chat application using React and the ",(0,a.jsx)(n.code,{children:"sync"})," API:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import React, { useState, useEffect, useRef } from "react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/react";\n\n// Define our chat store structure\ninterface Message {\n  id: string;\n  user: string;\n  text: string;\n  timestamp: number;\n}\n\ninterface User {\n  id: string;\n  name: string;\n  status: "online" | "offline" | "typing";\n}\n\ninterface ChatStore {\n  messages: Message[];\n  users: User[];\n  currentUser: User;\n}\n\n// Create the store\nconst chatStore = store<ChatStore>({\n  messages: [],\n  users: [],\n  currentUser: {\n    id: `user-${Math.random().toString(36).substr(2, 9)}`,\n    name: "Guest",\n    status: "online",\n  },\n});\n\n// Chat component\nfunction ChatApp() {\n  const state = useJods(chatStore);\n  const [connected, setConnected] = useState(false);\n  const [inputText, setInputText] = useState("");\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  // Auto-scroll to bottom of messages\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });\n  }, [state.messages.length]);\n\n  // Setup WebSocket and sync\n  useEffect(() => {\n    // Real app would use a server URL here\n    const socket = new WebSocket("wss://chat-server.example.com/ws");\n\n    // Connection status handlers\n    socket.addEventListener("open", () => {\n      setConnected(true);\n\n      // Announce our user joined\n      socket.send(\n        JSON.stringify({\n          type: "user-joined",\n          payload: chatStore.currentUser,\n        })\n      );\n    });\n\n    socket.addEventListener("close", () => {\n      setConnected(false);\n    });\n\n    // Setup sync when socket is ready\n    let stopSync: (() => void) | null = null;\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, chatStore, {\n        // Only sync these props for security\n        allowKeys: ["messages", "users"],\n        // Don\'t sync too frequently\n        throttleMs: 300,\n      });\n    });\n\n    // Clean up\n    return () => {\n      if (stopSync) stopSync();\n\n      // Tell server we\'re leaving\n      if (socket.readyState === WebSocket.OPEN) {\n        socket.send(\n          JSON.stringify({\n            type: "user-left",\n            payload: { id: chatStore.currentUser.id },\n          })\n        );\n      }\n\n      socket.close();\n    };\n  }, []);\n\n  // Send a new message\n  const sendMessage = (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!inputText.trim()) return;\n\n    // Add to local store\n    chatStore.messages.push({\n      id: `msg-${Date.now()}`,\n      user: chatStore.currentUser.name,\n      text: inputText,\n      timestamp: Date.now(),\n    });\n\n    setInputText("");\n  };\n\n  // Set typing status\n  const handleTyping = () => {\n    chatStore.currentUser.status = "typing";\n\n    // Reset status after a delay\n    setTimeout(() => {\n      if (chatStore.currentUser.status === "typing") {\n        chatStore.currentUser.status = "online";\n      }\n    }, 2000);\n  };\n\n  return (\n    <div className="chat-container">\n      <div className="chat-header">\n        <h2>Chat Room</h2>\n        <div className={`status ${connected ? "connected" : "disconnected"}`}>\n          {connected ? "Connected" : "Disconnected"}\n        </div>\n      </div>\n\n      <div className="chat-main">\n        <div className="message-list">\n          {state.messages.map((msg) => (\n            <div\n              key={msg.id}\n              className={`message ${\n                msg.user === state.currentUser.name ? "own" : ""\n              }`}\n            >\n              <div className="message-header">\n                <strong>{msg.user}</strong>\n                <span className="time">\n                  {new Date(msg.timestamp).toLocaleTimeString()}\n                </span>\n              </div>\n              <div className="message-body">{msg.text}</div>\n            </div>\n          ))}\n          <div ref={messagesEndRef} />\n        </div>\n\n        <div className="users-list">\n          <h3>Online Users ({state.users.length})</h3>\n          <ul>\n            {state.users.map((user) => (\n              <li key={user.id}>\n                {user.name}\n                {user.status === "typing" && <span> (typing...)</span>}\n              </li>\n            ))}\n          </ul>\n        </div>\n      </div>\n\n      <form className="message-form" onSubmit={sendMessage}>\n        <input\n          type="text"\n          value={inputText}\n          onChange={(e) => setInputText(e.target.value)}\n          onKeyDown={handleTyping}\n          placeholder="Type a message..."\n          disabled={!connected}\n        />\n        <button type="submit" disabled={!connected}>\n          Send\n        </button>\n      </form>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"collaborative-todo-application-with-real-time-updates",children:"Collaborative Todo Application with Real-time Updates"}),"\n",(0,a.jsx)(n.p,{children:"This example demonstrates a collaborative todo application where multiple users can work on the same todo list:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import React, { useEffect, useState } from "react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/react";\n\n// Define todo types\ninterface Todo {\n  id: string;\n  text: string;\n  completed: boolean;\n  assignee: string | null;\n  createdBy: string;\n  createdAt: number;\n}\n\ninterface TodoStore {\n  todos: Todo[];\n  filter: "all" | "active" | "completed";\n  users: string[];\n}\n\n// Create the store\nconst todoStore = store<TodoStore>({\n  todos: [],\n  filter: "all",\n  users: [],\n});\n\n// Generate a user ID (in a real app, this would come from authentication)\nconst userId = `user-${Math.random().toString(36).substr(2, 9)}`;\n\nfunction TodoApp() {\n  const state = useJods(todoStore);\n  const [isConnected, setIsConnected] = useState(false);\n  const [newTodoText, setNewTodoText] = useState("");\n\n  // Setup WebSocket and sync\n  useEffect(() => {\n    // Add current user\n    if (!todoStore.users.includes(userId)) {\n      todoStore.users.push(userId);\n    }\n\n    // Connect to WebSocket\n    const socket = new WebSocket("wss://todos-api.example.com/collab");\n\n    socket.addEventListener("open", () => {\n      setIsConnected(true);\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    // Start syncing\n    let stopSync: (() => void) | null = null;\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, todoStore);\n    });\n\n    // Clean up\n    return () => {\n      // Remove this user\n      todoStore.users = todoStore.users.filter((id) => id !== userId);\n\n      if (stopSync) stopSync();\n      socket.close();\n    };\n  }, []);\n\n  // Get filtered todos\n  const filteredTodos = state.todos.filter((todo) => {\n    if (state.filter === "active") return !todo.completed;\n    if (state.filter === "completed") return todo.completed;\n    return true;\n  });\n\n  // Add a new todo\n  const addTodo = (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!newTodoText.trim()) return;\n\n    todoStore.todos.push({\n      id: `todo-${Date.now()}`,\n      text: newTodoText,\n      completed: false,\n      assignee: null,\n      createdBy: userId,\n      createdAt: Date.now(),\n    });\n\n    setNewTodoText("");\n  };\n\n  // Toggle todo completion\n  const toggleTodo = (id: string) => {\n    const todo = todoStore.todos.find((t) => t.id === id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  // Assign todo to yourself\n  const assignToMe = (id: string) => {\n    const todo = todoStore.todos.find((t) => t.id === id);\n    if (todo) {\n      todo.assignee = todo.assignee === userId ? null : userId;\n    }\n  };\n\n  return (\n    <div className="todo-app">\n      <header>\n        <h1>Collaborative Todo List</h1>\n        <div className={`status ${isConnected ? "online" : "offline"}`}>\n          {isConnected ? "Online" : "Offline"}\n        </div>\n        <div className="active-users">\n          {state.users.length} user{state.users.length !== 1 ? "s" : ""} online\n        </div>\n      </header>\n\n      <div className="filters">\n        <button\n          className={state.filter === "all" ? "active" : ""}\n          onClick={() => {\n            todoStore.filter = "all";\n          }}\n        >\n          All\n        </button>\n        <button\n          className={state.filter === "active" ? "active" : ""}\n          onClick={() => {\n            todoStore.filter = "active";\n          }}\n        >\n          Active\n        </button>\n        <button\n          className={state.filter === "completed" ? "active" : ""}\n          onClick={() => {\n            todoStore.filter = "completed";\n          }}\n        >\n          Completed\n        </button>\n      </div>\n\n      <form onSubmit={addTodo}>\n        <input\n          type="text"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder="What needs to be done?"\n        />\n        <button type="submit">Add</button>\n      </form>\n\n      <ul className="todo-list">\n        {filteredTodos.map((todo) => (\n          <li key={todo.id} className={todo.completed ? "completed" : ""}>\n            <input\n              type="checkbox"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id)}\n            />\n            <span className="todo-text">{todo.text}</span>\n            <button\n              className={`assign ${todo.assignee === userId ? "assigned" : ""}`}\n              onClick={() => assignToMe(todo.id)}\n            >\n              {todo.assignee === userId ? "Assigned to me" : "Assign to me"}\n            </button>\n            <span className="created-by">\n              Created by: {todo.createdBy === userId ? "you" : todo.createdBy}\n            </span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"preact-examples",children:"Preact Examples"}),"\n",(0,a.jsx)(n.h3,{id:"cross-tab-synchronization-with-broadcastchannel",children:"Cross-Tab Synchronization with BroadcastChannel"}),"\n",(0,a.jsx)(n.p,{children:"This example demonstrates how to synchronize data between different browser tabs using Preact and BroadcastChannel:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import { h } from "preact";\nimport { useState, useEffect } from "preact/hooks";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/preact";\n\n// Define the store structure\ninterface PreferencesStore {\n  theme: "light" | "dark" | "system";\n  fontSize: number;\n  notifications: boolean;\n  lastUpdated: number;\n  updatedBy: string;\n}\n\n// Create a store with initial values\nconst preferencesStore = store<PreferencesStore>({\n  theme: "system",\n  fontSize: 16,\n  notifications: true,\n  lastUpdated: Date.now(),\n  updatedBy: "default",\n});\n\n// Generate a unique ID for this tab\nconst tabId = `tab-${Math.random().toString(36).substr(2, 9)}`;\n\nfunction PreferencesApp() {\n  const state = useJods(preferencesStore);\n  const [syncActive, setSyncActive] = useState(false);\n\n  // Set up cross-tab sync with BroadcastChannel\n  useEffect(() => {\n    // Create a broadcast channel\n    const channel = new BroadcastChannel("app-preferences");\n\n    // Start syncing\n    const stopSync = sync(channel, preferencesStore);\n    setSyncActive(true);\n\n    // Clean up on unmount\n    return () => {\n      stopSync();\n      channel.close();\n      setSyncActive(false);\n    };\n  }, []);\n\n  // Update a preference and mark who updated it\n  const updatePreference = (key: keyof PreferencesStore, value: any) => {\n    preferencesStore[key] = value;\n    preferencesStore.lastUpdated = Date.now();\n    preferencesStore.updatedBy = tabId;\n  };\n\n  return (\n    <div class={`preferences-panel theme-${state.theme}`}>\n      <header>\n        <h1>User Preferences</h1>\n        <div class="sync-status">\n          {syncActive ? "Synced across tabs" : "Not synced"}\n        </div>\n        {state.updatedBy !== tabId && (\n          <div class="updated-notice">\n            Updated by another tab at{" "}\n            {new Date(state.lastUpdated).toLocaleTimeString()}\n          </div>\n        )}\n      </header>\n\n      <div class="preference-group">\n        <h2>Appearance</h2>\n\n        <div class="preference-item">\n          <label for="theme">Theme:</label>\n          <select\n            id="theme"\n            value={state.theme}\n            onChange={(e) => updatePreference("theme", e.target.value)}\n          >\n            <option value="light">Light</option>\n            <option value="dark">Dark</option>\n            <option value="system">System</option>\n          </select>\n        </div>\n\n        <div class="preference-item">\n          <label for="font-size">Font Size: {state.fontSize}px</label>\n          <input\n            id="font-size"\n            type="range"\n            min="12"\n            max="24"\n            value={state.fontSize}\n            onChange={(e) =>\n              updatePreference("fontSize", parseInt(e.target.value))\n            }\n          />\n        </div>\n      </div>\n\n      <div class="preference-group">\n        <h2>Notifications</h2>\n\n        <div class="preference-item">\n          <label for="notifications">Enable Notifications:</label>\n          <input\n            id="notifications"\n            type="checkbox"\n            checked={state.notifications}\n            onChange={(e) =>\n              updatePreference("notifications", e.target.checked)\n            }\n          />\n        </div>\n      </div>\n\n      <div class="preview-panel">\n        <h3>Preview</h3>\n        <p style={{ fontSize: `${state.fontSize}px` }}>\n          This text will display at {state.fontSize}px size with the{" "}\n          {state.theme} theme. Notifications are{" "}\n          {state.notifications ? "enabled" : "disabled"}.\n        </p>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"real-time-kanban-board",children:"Real-time Kanban Board"}),"\n",(0,a.jsx)(n.p,{children:"This example shows a real-time kanban board with Preact and the sync API:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import { h } from "preact";\nimport { useState, useEffect } from "preact/hooks";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/preact";\n\n// Define types\ninterface Task {\n  id: string;\n  title: string;\n  description: string;\n  status: "todo" | "doing" | "done";\n  assignee?: string;\n  createdAt: number;\n}\n\ninterface KanbanStore {\n  tasks: Task[];\n  users: string[];\n}\n\n// Create the store\nconst kanbanStore = store<KanbanStore>({\n  tasks: [],\n  users: [],\n});\n\n// Current user ID (in real app, from authentication)\nconst userId = `user-${Math.random().toString(36).substr(2, 9)}`;\nconst userName = `User ${userId.slice(-4)}`;\n\nfunction KanbanBoard() {\n  const state = useJods(kanbanStore);\n  const [isConnected, setIsConnected] = useState(false);\n  const [newTaskTitle, setNewTaskTitle] = useState("");\n\n  // Connect to WebSocket and set up sync\n  useEffect(() => {\n    // Add current user to users list\n    if (!kanbanStore.users.includes(userName)) {\n      kanbanStore.users.push(userName);\n    }\n\n    // Connect to WebSocket\n    const socket = new WebSocket("wss://kanban-api.example.com/board");\n\n    socket.addEventListener("open", () => {\n      setIsConnected(true);\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    // Set up sync\n    let stopSync: (() => void) | null = null;\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, kanbanStore);\n    });\n\n    // Clean up\n    return () => {\n      // Remove user from the list\n      kanbanStore.users = kanbanStore.users.filter((u) => u !== userName);\n\n      // Stop syncing and close socket\n      if (stopSync) stopSync();\n      socket.close();\n    };\n  }, []);\n\n  // Group tasks by status\n  const todoTasks = state.tasks.filter((task) => task.status === "todo");\n  const doingTasks = state.tasks.filter((task) => task.status === "doing");\n  const doneTasks = state.tasks.filter((task) => task.status === "done");\n\n  // Add a new task\n  const addTask = (e: Event) => {\n    e.preventDefault();\n\n    if (!newTaskTitle.trim()) return;\n\n    kanbanStore.tasks.push({\n      id: `task-${Date.now()}`,\n      title: newTaskTitle,\n      description: "",\n      status: "todo",\n      assignee: userName,\n      createdAt: Date.now(),\n    });\n\n    setNewTaskTitle("");\n  };\n\n  // Move a task to a different status\n  const moveTask = (taskId: string, newStatus: Task["status"]) => {\n    const task = kanbanStore.tasks.find((t) => t.id === taskId);\n    if (task) {\n      task.status = newStatus;\n    }\n  };\n\n  // Render a task card\n  const TaskCard = ({ task }: { task: Task }) => (\n    <div class="task-card">\n      <h3>{task.title}</h3>\n      {task.description && <p>{task.description}</p>}\n      <div class="task-footer">\n        <span class="assignee">{task.assignee || "Unassigned"}</span>\n        <div class="actions">\n          {task.status !== "todo" && (\n            <button onClick={() => moveTask(task.id, "todo")}>\u2190 To Do</button>\n          )}\n          {task.status !== "doing" && (\n            <button onClick={() => moveTask(task.id, "doing")}>\n              In Progress\n            </button>\n          )}\n          {task.status !== "done" && (\n            <button onClick={() => moveTask(task.id, "done")}>Done \u2192</button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n\n  return (\n    <div class="kanban-board">\n      <header class="board-header">\n        <h1>Kanban Board</h1>\n        <div class={`connection-status ${isConnected ? "online" : "offline"}`}>\n          {isConnected ? "Online" : "Offline"}\n        </div>\n        <div class="users-online">\n          {state.users.length} user{state.users.length !== 1 ? "s" : ""} online:\n          {state.users.map((user) => (\n            <span class="user-badge" key={user}>\n              {user}\n            </span>\n          ))}\n        </div>\n      </header>\n\n      <form class="new-task-form" onSubmit={addTask}>\n        <input\n          type="text"\n          value={newTaskTitle}\n          onChange={(e) => setNewTaskTitle(e.target.value)}\n          placeholder="New task title..."\n        />\n        <button type="submit">Add Task</button>\n      </form>\n\n      <div class="board-columns">\n        <div class="column todo-column">\n          <h2>To Do ({todoTasks.length})</h2>\n          {todoTasks.map((task) => (\n            <TaskCard task={task} key={task.id} />\n          ))}\n        </div>\n\n        <div class="column doing-column">\n          <h2>In Progress ({doingTasks.length})</h2>\n          {doingTasks.map((task) => (\n            <TaskCard task={task} key={task.id} />\n          ))}\n        </div>\n\n        <div class="column done-column">\n          <h2>Done ({doneTasks.length})</h2>\n          {doneTasks.map((task) => (\n            <TaskCard task={task} key={task.id} />\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"remix-examples",children:"Remix Examples"}),"\n",(0,a.jsx)(n.h3,{id:"collaborative-document-editor-with-server-persistence",children:"Collaborative Document Editor with Server Persistence"}),"\n",(0,a.jsx)(n.p,{children:"This example demonstrates a collaborative document editor in Remix that syncs changes in real-time between clients and persists to the server:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import { json } from "@remix-run/node";\nimport { useLoaderData, Form } from "@remix-run/react";\nimport { useEffect, useState } from "react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/remix";\n\n// Define our document structure\ninterface Document {\n  id: string;\n  title: string;\n  content: string;\n  lastEditedBy: string;\n  lastEditedAt: number;\n  collaborators: string[];\n}\n\n// Server-side loader function\nexport async function loader({ params }) {\n  const docId = params.docId;\n\n  // In a real app, fetch from database\n  const document = await fetchDocumentFromDatabase(docId);\n\n  return json({ document });\n}\n\n// Server-side action function\nexport async function action({ request, params }) {\n  const formData = await request.formData();\n  const intent = formData.get("intent");\n  const docId = params.docId;\n\n  if (intent === "save") {\n    const title = formData.get("title");\n    const content = formData.get("content");\n\n    // In a real app, save to database\n    await saveDocumentToDatabase(docId, { title, content });\n\n    return json({ success: true });\n  }\n\n  return json({ success: false });\n}\n\n// Create the document store (outside component to persist between renders)\nconst documentStore = store<Document>({\n  id: "",\n  title: "",\n  content: "",\n  lastEditedBy: "",\n  lastEditedAt: 0,\n  collaborators: [],\n});\n\n// Current user (in a real app, from authentication)\nconst currentUser = `user-${Math.random().toString(36).substr(2, 9)}`;\n\nexport default function DocumentEditor() {\n  const { document } = useLoaderData<{ document: Document }>();\n  const [isHydrated, setIsHydrated] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n  const [saveStatus, setSaveStatus] = useState("");\n\n  // Use the store\n  const state = useJods(documentStore);\n\n  // Initialize the store with data from the server\n  useEffect(() => {\n    if (!isHydrated) {\n      // Initialize with server data\n      documentStore.id = document.id;\n      documentStore.title = document.title;\n      documentStore.content = document.content;\n      documentStore.lastEditedBy = document.lastEditedBy;\n      documentStore.lastEditedAt = document.lastEditedAt;\n      documentStore.collaborators = [...document.collaborators];\n\n      // Add current user to collaborators if not already there\n      if (!documentStore.collaborators.includes(currentUser)) {\n        documentStore.collaborators.push(currentUser);\n      }\n\n      setIsHydrated(true);\n    }\n  }, [document]);\n\n  // Set up WebSocket connection and sync AFTER hydration\n  useEffect(() => {\n    if (!isHydrated) return;\n\n    // WebSocket connection\n    const socket = new WebSocket(\n      `wss://docs-api.example.com/documents/${documentStore.id}`\n    );\n\n    socket.addEventListener("open", () => {\n      setIsConnected(true);\n    });\n\n    socket.addEventListener("close", () => {\n      setIsConnected(false);\n    });\n\n    // Set up sync\n    let stopSync: (() => void) | null = null;\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, documentStore, {\n        // Don\'t sync too frequently (typing can generate many changes)\n        throttleMs: 500,\n      });\n    });\n\n    // Auto-save after changes are made\n    let autoSaveTimeout: number | null = null;\n\n    const setupAutoSave = () => {\n      if (autoSaveTimeout) {\n        clearTimeout(autoSaveTimeout);\n      }\n\n      autoSaveTimeout = window.setTimeout(() => {\n        saveDocument();\n      }, 3000); // Save 3 seconds after last edit\n    };\n\n    // Subscribe to store changes\n    const unsubscribe = documentStore.subscribe((newState) => {\n      // Update last edited\n      documentStore.lastEditedBy = currentUser;\n      documentStore.lastEditedAt = Date.now();\n\n      // Schedule auto-save\n      setupAutoSave();\n    });\n\n    // Clean up\n    return () => {\n      if (stopSync) stopSync();\n      if (unsubscribe) unsubscribe();\n      if (autoSaveTimeout) clearTimeout(autoSaveTimeout);\n\n      // Remove from collaborators when leaving\n      documentStore.collaborators = documentStore.collaborators.filter(\n        (user) => user !== currentUser\n      );\n\n      socket.close();\n    };\n  }, [isHydrated]);\n\n  // Save document to server\n  const saveDocument = async () => {\n    setIsSaving(true);\n    setSaveStatus("Saving...");\n\n    try {\n      const formData = new FormData();\n      formData.append("intent", "save");\n      formData.append("title", documentStore.title);\n      formData.append("content", documentStore.content);\n\n      const response = await fetch(`/documents/${documentStore.id}`, {\n        method: "POST",\n        body: formData,\n      });\n\n      const result = await response.json();\n\n      if (result.success) {\n        setSaveStatus("Saved");\n      } else {\n        setSaveStatus("Error saving");\n      }\n    } catch (error) {\n      setSaveStatus("Error saving");\n      console.error("Error saving document:", error);\n    } finally {\n      setIsSaving(false);\n\n      // Clear the status after a while\n      setTimeout(() => {\n        setSaveStatus("");\n      }, 3000);\n    }\n  };\n\n  return (\n    <div className="document-editor">\n      <header className="editor-header">\n        <input\n          type="text"\n          className="title-input"\n          value={state.title}\n          onChange={(e) => {\n            documentStore.title = e.target.value;\n          }}\n          placeholder="Document Title"\n        />\n\n        <div className="status-indicators">\n          <div className={`connection ${isConnected ? "online" : "offline"}`}>\n            {isConnected ? "Connected" : "Offline"}\n          </div>\n\n          <div className="save-status">{saveStatus}</div>\n\n          <div className="collaborators">\n            {state.collaborators.length} editing now\n          </div>\n        </div>\n\n        <button\n          onClick={saveDocument}\n          disabled={isSaving}\n          className="save-button"\n        >\n          {isSaving ? "Saving..." : "Save"}\n        </button>\n      </header>\n\n      <div className="editor-main">\n        <textarea\n          className="content-editor"\n          value={state.content}\n          onChange={(e) => {\n            documentStore.content = e.target.value;\n          }}\n          placeholder="Start typing here..."\n        />\n      </div>\n\n      <footer className="editor-footer">\n        <div className="last-edited">\n          {state.lastEditedBy && (\n            <>\n              Last edited by{" "}\n              {state.lastEditedBy === currentUser ? "you" : state.lastEditedBy}\n              {" at "}\n              {new Date(state.lastEditedAt).toLocaleString()}\n            </>\n          )}\n        </div>\n\n        <div className="word-count">\n          {state.content.split(/\\s+/).filter(Boolean).length} words\n        </div>\n      </footer>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"real-time-dashboard-with-server-sent-events-and-websockets",children:"Real-time Dashboard with Server-Sent Events and WebSockets"}),"\n",(0,a.jsx)(n.p,{children:"This example shows how to build a dashboard in Remix that receives real-time updates through both SSE and WebSockets:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import { json } from "@remix-run/node";\nimport { useLoaderData, useFetcher } from "@remix-run/react";\nimport { useEffect, useState } from "react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/remix";\n\n// Define dashboard data types\ninterface DashboardStats {\n  activeUsers: number;\n  totalSales: number;\n  conversionRate: number;\n  pageViews: number;\n  lastUpdated: string;\n}\n\ninterface AlertMessage {\n  id: string;\n  type: "info" | "warning" | "error";\n  message: string;\n  timestamp: number;\n}\n\ninterface DashboardStore {\n  stats: DashboardStats;\n  alerts: AlertMessage[];\n  isDataStale: boolean;\n}\n\n// Server-side loader function\nexport async function loader() {\n  // Fetch initial data from database or API\n  const dashboardStats = await fetchDashboardStats();\n  const recentAlerts = await fetchRecentAlerts();\n\n  return json({\n    stats: dashboardStats,\n    alerts: recentAlerts,\n  });\n}\n\n// Dashboard store (outside component to persist between renders)\nconst dashboardStore = store<DashboardStore>({\n  stats: {\n    activeUsers: 0,\n    totalSales: 0,\n    conversionRate: 0,\n    pageViews: 0,\n    lastUpdated: "",\n  },\n  alerts: [],\n  isDataStale: false,\n});\n\nexport default function Dashboard() {\n  const initialData = useLoaderData();\n  const fetcher = useFetcher();\n  const [isHydrated, setIsHydrated] = useState(false);\n  const [wsConnected, setWsConnected] = useState(false);\n  const [sseConnected, setSseConnected] = useState(false);\n\n  // Use the store with Remix hook\n  const state = useJods(dashboardStore);\n\n  // Initialize store with server data\n  useEffect(() => {\n    if (!isHydrated) {\n      dashboardStore.stats = initialData.stats;\n      dashboardStore.alerts = initialData.alerts;\n      dashboardStore.isDataStale = false;\n      setIsHydrated(true);\n    }\n  }, [initialData]);\n\n  // Set up SSE for real-time statistics updates\n  useEffect(() => {\n    if (!isHydrated) return;\n\n    const eventSource = new EventSource("/api/dashboard-stats/sse");\n\n    eventSource.onopen = () => {\n      setSseConnected(true);\n    };\n\n    eventSource.onerror = () => {\n      setSseConnected(false);\n    };\n\n    // Listen for stats updates\n    eventSource.addEventListener("stats-update", (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        dashboardStore.stats = {\n          ...dashboardStore.stats,\n          ...data,\n          lastUpdated: new Date().toISOString(),\n        };\n        dashboardStore.isDataStale = false;\n      } catch (error) {\n        console.error("Error parsing SSE data:", error);\n      }\n    });\n\n    // Clean up\n    return () => {\n      eventSource.close();\n      setSseConnected(false);\n    };\n  }, [isHydrated]);\n\n  // Set up WebSocket for alerts and interactive features\n  useEffect(() => {\n    if (!isHydrated) return;\n\n    const socket = new WebSocket("wss://dashboard-api.example.com/alerts");\n\n    socket.addEventListener("open", () => {\n      setWsConnected(true);\n    });\n\n    socket.addEventListener("close", () => {\n      setWsConnected(false);\n    });\n\n    // Set up sync for bidirectional communication\n    let stopSync: (() => void) | null = null;\n\n    socket.addEventListener("open", () => {\n      stopSync = sync(socket, dashboardStore, {\n        // Only sync alerts, not stats (those come from SSE)\n        allowKeys: ["alerts"],\n      });\n    });\n\n    // After 60 seconds of no SSE updates, mark data as stale\n    const staleDataCheck = setInterval(() => {\n      const lastUpdateTime = new Date(\n        dashboardStore.stats.lastUpdated\n      ).getTime();\n      const now = Date.now();\n      const timeSinceUpdate = now - lastUpdateTime;\n\n      if (timeSinceUpdate > 60000) {\n        // 60 seconds\n        dashboardStore.isDataStale = true;\n      }\n    }, 10000); // Check every 10 seconds\n\n    // Clean up\n    return () => {\n      if (stopSync) stopSync();\n      socket.close();\n      clearInterval(staleDataCheck);\n    };\n  }, [isHydrated]);\n\n  // Manual refresh button handler\n  const refreshData = () => {\n    fetcher.load("/dashboard?fresh=1");\n\n    // When the data comes back, update our store\n    if (fetcher.data) {\n      dashboardStore.stats = fetcher.data.stats;\n      dashboardStore.alerts = fetcher.data.alerts;\n      dashboardStore.isDataStale = false;\n    }\n  };\n\n  // Dismiss an alert\n  const dismissAlert = (alertId: string) => {\n    dashboardStore.alerts = dashboardStore.alerts.filter(\n      (alert) => alert.id !== alertId\n    );\n  };\n\n  return (\n    <div className="dashboard">\n      <header className="dashboard-header">\n        <h1>Real-time Dashboard</h1>\n\n        <div className="connection-status">\n          <div\n            className={`sse-status ${\n              sseConnected ? "connected" : "disconnected"\n            }`}\n          >\n            Stats: {sseConnected ? "Live" : "Offline"}\n          </div>\n          <div\n            className={`ws-status ${\n              wsConnected ? "connected" : "disconnected"\n            }`}\n          >\n            Alerts: {wsConnected ? "Live" : "Offline"}\n          </div>\n        </div>\n\n        <button\n          className="refresh-button"\n          onClick={refreshData}\n          disabled={fetcher.state === "loading"}\n        >\n          {fetcher.state === "loading" ? "Refreshing..." : "Refresh"}\n        </button>\n      </header>\n\n      <div className="dashboard-content">\n        <div className="stats-panel">\n          <h2>\n            Live Statistics\n            {state.isDataStale && <span className="stale-badge">Stale</span>}\n          </h2>\n\n          <div className="stats-grid">\n            <div className="stat-card">\n              <h3>Active Users</h3>\n              <div className="stat-value">{state.stats.activeUsers}</div>\n            </div>\n\n            <div className="stat-card">\n              <h3>Total Sales</h3>\n              <div className="stat-value">\n                ${state.stats.totalSales.toLocaleString()}\n              </div>\n            </div>\n\n            <div className="stat-card">\n              <h3>Conversion Rate</h3>\n              <div className="stat-value">{state.stats.conversionRate}%</div>\n            </div>\n\n            <div className="stat-card">\n              <h3>Page Views</h3>\n              <div className="stat-value">\n                {state.stats.pageViews.toLocaleString()}\n              </div>\n            </div>\n          </div>\n\n          <div className="last-updated">\n            Last updated: {new Date(state.stats.lastUpdated).toLocaleString()}\n          </div>\n        </div>\n\n        <div className="alerts-panel">\n          <h2>Alerts ({state.alerts.length})</h2>\n\n          {state.alerts.length === 0 ? (\n            <div className="no-alerts">No alerts at this time</div>\n          ) : (\n            <ul className="alerts-list">\n              {state.alerts.map((alert) => (\n                <li key={alert.id} className={`alert alert-${alert.type}`}>\n                  <span className="alert-message">{alert.message}</span>\n                  <span className="alert-time">\n                    {new Date(alert.timestamp).toLocaleTimeString()}\n                  </span>\n                  <button\n                    className="dismiss-alert"\n                    onClick={() => dismissAlert(alert.id)}\n                  >\n                    \xd7\n                  </button>\n                </li>\n              ))}\n            </ul>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"customizing-sync-behavior",children:"Customizing Sync Behavior"}),"\n",(0,a.jsx)(n.p,{children:"These examples demonstrate basic integration, but the sync API offers many customization options:"}),"\n",(0,a.jsx)(n.h3,{id:"security-and-selective-syncing",children:"Security and Selective Syncing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'// Only sync specific properties\nconst stopSync = sync(socket, store, {\n  // Only sync these top-level keys\n  allowKeys: ["publicData", "sharedSettings"],\n\n  // Block these specific paths\n  sensitiveKeys: ["user.password", "user.email", "paymentInfo"],\n\n  // Validate against schema\n  validateSchema: (changes) => {\n    try {\n      mySchema.parse(changes);\n      return true;\n    } catch (error) {\n      console.error("Schema validation failed:", error);\n      return false;\n    }\n  },\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"// Throttle updates for better performance\nconst stopSync = sync(socket, store, {\n  // Only send updates at most every 500ms\n  throttleMs: 500,\n\n  // Limit message size\n  maxMessageSize: 100 * 1024, // 100KB\n\n  // Custom filter to prevent unnecessary updates\n  filter: (changes) => {\n    // Only sync if changes match certain criteria\n    if (Object.keys(changes).length === 0) return false;\n    if (changes.debugData) return false;\n    return true;\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"custom-transformations",children:"Custom Transformations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'// Transform data before sending/receiving\nconst stopSync = sync(socket, store, {\n  // Transform outgoing patches\n  mapToPatch: (changes) => {\n    // Add metadata\n    return {\n      ...changes,\n      _meta: {\n        clientVersion: "1.2.3",\n        timestamp: Date.now(),\n      },\n    };\n  },\n\n  // Transform incoming patches\n  mapFromPatch: (changes) => {\n    // Extract and use metadata\n    const { _meta, ...actualChanges } = changes;\n    console.log("Received update from version:", _meta?.clientVersion);\n    return actualChanges;\n  },\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"debugging-and-monitoring",children:"Debugging and Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'// Add callbacks for debugging\nconst stopSync = sync(socket, store, {\n  onDiffSend: (message) => {\n    console.log("Sending update:", message);\n  },\n\n  onPatchReceive: (message) => {\n    console.log("Received update:", message);\n  },\n\n  onError: (error) => {\n    console.error("Sync error:", error);\n  },\n});\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);