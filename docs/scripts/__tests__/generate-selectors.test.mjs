import { test, expect, vi, beforeEach } from "vitest";

// Mock dependencies
vi.mock("@playwright/test", () => ({
  chromium: {
    launch: vi.fn().mockResolvedValue({
      newContext: vi.fn().mockResolvedValue({
        newPage: vi.fn().mockResolvedValue({
          goto: vi.fn().mockResolvedValue(),
          $$: vi.fn(),
        }),
      }),
      close: vi.fn().mockResolvedValue(),
    }),
  },
}));

vi.mock("fs", () => ({
  writeFileSync: vi.fn(),
}));

vi.mock("path", () => ({
  join: (...args) => args.join("/"),
  dirname: vi.fn().mockReturnValue("/mocked/path"),
}));

vi.mock("url", () => ({
  fileURLToPath: vi.fn().mockReturnValue("/mocked/file/url"),
}));

// Import after mocking
import fs from "fs";
import { chromium } from "@playwright/test";
import { generateScreenshotSelectors } from "../generate-selectors.mjs";

// Since most functions in the module are not exported, we need to recreate them for testing
// These are copied from the original implementation for testing purposes

/**
 * Create a component configuration object
 */
function createComponent(element, name, isSection, additionalProps = {}) {
  // Calculate padding based on element size and type
  const padding = isSection ? 50 : 20;

  // Calculate min height based on element size
  const minHeight = element.rect ? Math.max(element.rect.height, 500) : 500;

  // Basic component config
  const component = {
    page: "/",
    name,
    selector: `[data-testid="${element.testId}"]`,
    fallbackStrategy: isSection ? "keyword-context" : undefined,
    keywords: extractKeywords(element.textContent),
    padding,
    minHeight,
    testId: element.testId,
    alternativeSelectors: [
      `[data-testid="${element.testId}"]`,
      isSection
        ? `section:has(h2:has-text("${getHeadingText(element.textContent)}"))`
        : null,
    ].filter(Boolean),
  };

  // Add additional properties
  return {
    ...component,
    ...additionalProps,
  };
}

/**
 * Extract important keywords from text content
 */
function extractKeywords(text) {
  if (!text) return [];

  // Split by common separators and get words
  const words = text
    .split(/[\n\r\t,.]/)
    .map((word) => word.trim())
    .filter((word) => word.length > 3)
    .slice(0, 5); // Limit to 5 keywords

  return words;
}

/**
 * Extract potential heading text from content
 */
function getHeadingText(text) {
  if (!text) return "";

  // Try to find a heading-like phrase
  const lines = text
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean);

  // Return the first line that seems like a heading (shorter than 50 chars)
  for (const line of lines) {
    if (line.length < 50) {
      return line;
    }
  }

  // Fallback to first 30 chars
  return text.substring(0, 30).trim();
}

/**
 * Generate the code for the output file
 */
function generateCode(components) {
  const timestamp = new Date().toISOString();

  const template = `// Generated screenshot selectors based on data-testid attributes
// Generated on: ${timestamp}
// DO NOT EDIT THIS FILE DIRECTLY

// Export the components array
export const GENERATED_COMPONENTS = ${JSON.stringify(components, null, 2)};

// Helper function to merge with existing components
export function mergeWithExisting(existingComponents) {
  const existing = new Map(existingComponents.map(c => [c.name, c]));
  
  // Replace or add generated components
  for (const component of GENERATED_COMPONENTS) {
    existing.set(component.name, component);
  }
  
  return Array.from(existing.values());
}

// Default export for directly using these components
export default GENERATED_COMPONENTS;
`;

  return template;
}

// Mocked elements for testing
const mockElements = [
  // Hero section
  {
    testId: "jods-hero-section",
    tagName: "section",
    rect: { x: 0, y: 0, width: 1200, height: 600 },
    textContent:
      "jods\nPowerful features in a lightweight package\nGet Started",
    classList: ["hero", "container"],
    hasChildren: true,
    isInteractive: false,
  },
  // Features section
  {
    testId: "jods-features-section",
    tagName: "section",
    rect: { x: 0, y: 700, width: 1200, height: 800 },
    textContent:
      "Powerful features\nReactive state\nJSON snapshots\nComputed values",
    classList: ["features"],
    hasChildren: true,
    isInteractive: false,
  },
  // Framework tab-related elements
  {
    testId: "jods-framework-section",
    tagName: "section",
    rect: { x: 0, y: 1600, width: 1200, height: 1000 },
    textContent:
      "Works with your favorite frameworks\nReact, Preact, and Remix integration",
    classList: ["framework-section"],
    hasChildren: true,
    isInteractive: false,
  },
  {
    testId: "jods-framework-tab-react",
    tagName: "button",
    rect: { x: 100, y: 1700, width: 80, height: 40 },
    textContent: "React",
    classList: ["tab", "active"],
    hasChildren: false,
    isInteractive: true,
  },
  {
    testId: "jods-framework-tab-remix",
    tagName: "button",
    rect: { x: 190, y: 1700, width: 80, height: 40 },
    textContent: "Remix",
    classList: ["tab"],
    hasChildren: false,
    isInteractive: true,
  },
];

beforeEach(() => {
  vi.clearAllMocks();
  // Fix Date to make tests predictable
  vi.useFakeTimers();
  vi.setSystemTime(new Date("2023-01-01T12:00:00Z"));
});

afterEach(() => {
  vi.useRealTimers();
});

test("extractKeywords should extract important words from text", () => {
  const text = "jods\nPowerful features in a lightweight package\nGet Started";
  const keywords = extractKeywords(text);

  expect(keywords).toContain("Powerful");
  expect(keywords).toContain("features");
  expect(keywords).toContain("lightweight");
  expect(keywords).toContain("package");
  expect(keywords).toHaveLength(4); // All words that are > 3 chars up to 5 total
});

test("extractKeywords should handle empty or undefined text", () => {
  expect(extractKeywords("")).toEqual([]);
  expect(extractKeywords(undefined)).toEqual([]);
  expect(extractKeywords(null)).toEqual([]);
});

test("getHeadingText should extract heading text from content", () => {
  const text1 = "Powerful features\nReactive state\nJSON snapshots";
  expect(getHeadingText(text1)).toBe("Powerful features");

  const text2 =
    "This is a very long heading that exceeds fifty characters and should not be selected\nShort heading\nMore content";
  expect(getHeadingText(text2)).toBe("Short heading");

  // Test with no valid heading
  const text3 =
    "This is a very long text without any line breaks and it just keeps going and going beyond fifty characters";
  expect(getHeadingText(text3)).toBe("This is a very long text without any");
});

test("createComponent should create correct component config", () => {
  const element = mockElements[0]; // Hero section
  const component = createComponent(element, "hero-section", true);

  expect(component).toEqual({
    page: "/",
    name: "hero-section",
    selector: '[data-testid="jods-hero-section"]',
    fallbackStrategy: "keyword-context",
    keywords: ["Powerful", "features", "lightweight", "package"],
    padding: 50, // Section padding
    minHeight: 600, // Based on element height
    testId: "jods-hero-section",
    alternativeSelectors: [
      '[data-testid="jods-hero-section"]',
      'section:has(h2:has-text("jods"))',
    ],
  });

  // Test non-section component
  const tabElement = mockElements[3]; // React tab
  const tabComponent = createComponent(
    tabElement,
    "framework-tab-react",
    false,
    {
      clickSelector: '[data-testid="jods-framework-tab-react"]',
    }
  );

  expect(tabComponent).toEqual({
    page: "/",
    name: "framework-tab-react",
    selector: '[data-testid="jods-framework-tab-react"]',
    fallbackStrategy: undefined, // Not a section
    keywords: ["React"], // From text content
    padding: 20, // Non-section padding
    minHeight: 500, // Minimum height
    testId: "jods-framework-tab-react",
    alternativeSelectors: ['[data-testid="jods-framework-tab-react"]'],
    clickSelector: '[data-testid="jods-framework-tab-react"]',
  });
});

test("generateCode should produce the correct template", () => {
  const components = [{ name: "test-component", page: "/" }];

  const code = generateCode(components);

  // Check for key parts of the template
  expect(code).toContain(
    "// Generated screenshot selectors based on data-testid attributes"
  );
  expect(code).toContain("// Generated on: 2023-01-01T12:00:00.000Z");
  expect(code).toContain("export const GENERATED_COMPONENTS =");
  expect(code).toContain('"name": "test-component"');
  expect(code).toContain("export function mergeWithExisting");
  expect(code).toContain("export default GENERATED_COMPONENTS");
});

test("generateScreenshotSelectors should process elements and generate components", async () => {
  // Mock the Playwright element discovery
  const mockPage = {
    goto: vi.fn().mockResolvedValue(),
    $$: vi.fn().mockResolvedValue(
      // Create mock Playwright elements
      mockElements.map((el) => ({
        getAttribute: vi.fn().mockResolvedValue(el.testId),
        evaluate: vi
          .fn()
          .mockResolvedValueOnce(el.tagName) // For tagName
          .mockResolvedValueOnce(el.textContent) // For textContent
          .mockResolvedValueOnce(el.classList) // For classList
          .mockResolvedValueOnce(el.hasChildren) // For hasChildren
          .mockResolvedValueOnce(el.isInteractive), // For isInteractive
        boundingBox: vi.fn().mockResolvedValue(el.rect),
      }))
    ),
  };

  // Update the mock to return our mock page
  const mockBrowser = {
    newContext: vi.fn().mockResolvedValue({
      newPage: vi.fn().mockResolvedValue(mockPage),
    }),
    close: vi.fn().mockResolvedValue(),
  };

  chromium.launch.mockResolvedValue(mockBrowser);

  // Run the function
  const result = await generateScreenshotSelectors();

  // Verify browser was launched
  expect(chromium.launch).toHaveBeenCalled();
  expect(mockBrowser.newContext).toHaveBeenCalled();
  expect(mockPage.goto).toHaveBeenCalled();
  expect(mockPage.$$).toHaveBeenCalledWith('[data-testid^="jods-"]');

  // Verify components were generated
  expect(Array.isArray(result)).toBe(true);
  expect(result.length).toBeGreaterThan(0);

  // Verify file was written
  expect(fs.writeFileSync).toHaveBeenCalled();
  const writeCall = fs.writeFileSync.mock.calls[0];
  expect(writeCall[0]).toContain("screenshot-selectors.generated.mjs");
  expect(writeCall[1]).toContain("export const GENERATED_COMPONENTS =");

  // Verify browser was closed
  expect(mockBrowser.close).toHaveBeenCalled();
});
