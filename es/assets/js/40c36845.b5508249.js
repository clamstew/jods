"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[954],{3774:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var r=s(6672);const t={},i=r.createContext(t);function c(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),r.createElement(i.Provider,{value:n},e.children)}},4609:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"guides/performance-best-practices","title":"Performance Best Practices","description":"Optimize your jods implementation for maximum performance","source":"@site/docs/guides/performance-best-practices.md","sourceDirName":"guides","slug":"/guides/performance-best-practices","permalink":"/jods/es/guides/performance-best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/guides/performance-best-practices.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Performance Best Practices","description":"Optimize your jods implementation for maximum performance"}}');var t=s(3420),i=s(3774);const c={sidebar_position:2,title:"Performance Best Practices",description:"Optimize your jods implementation for maximum performance"},a="Performance Best Practices",o={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Understanding Reactivity in jods",id:"understanding-reactivity-in-jods",level:2},{value:"Key Performance Principles",id:"key-performance-principles",level:2},{value:"1. Minimize Unnecessary Subscriptions",id:"1-minimize-unnecessary-subscriptions",level:3},{value:"2. Use Computed Properties Effectively",id:"2-use-computed-properties-effectively",level:3},{value:"3. Avoid Deep Nesting When Possible",id:"3-avoid-deep-nesting-when-possible",level:3},{value:"4. Handle Complex Data Structures Correctly",id:"4-handle-complex-data-structures-correctly",level:3},{value:"5. Batch Updates When Possible",id:"5-batch-updates-when-possible",level:3},{value:"6. Optimize State Structure for Access Patterns",id:"6-optimize-state-structure-for-access-patterns",level:3},{value:"Advanced Performance Techniques",id:"advanced-performance-techniques",level:2},{value:"Use Selector Functions for Precise Subscriptions",id:"use-selector-functions-for-precise-subscriptions",level:3},{value:"Memoize Expensive Computations",id:"memoize-expensive-computations",level:3},{value:"Consider Data Structure Size",id:"consider-data-structure-size",level:3},{value:"Upcoming Performance Features",id:"upcoming-performance-features",level:2},{value:"Performance Debugging",id:"performance-debugging",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"performance-best-practices",children:"Performance Best Practices"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"jods is designed to be lightweight and efficient, but like any reactive state management system, improper usage can lead to performance issues. This guide covers best practices to ensure your jods implementation remains performant, even with complex state structures."}),"\n",(0,t.jsx)(n.h2,{id:"understanding-reactivity-in-jods",children:"Understanding Reactivity in jods"}),"\n",(0,t.jsx)(n.p,{children:"jods uses a proxy-based reactivity system to track property access and mutations. When you update a property, jods:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Detects the change through its proxy handler"}),"\n",(0,t.jsx)(n.li,{children:"Compares the new value with the old value"}),"\n",(0,t.jsx)(n.li,{children:"Updates internal state"}),"\n",(0,t.jsx)(n.li,{children:"Notifies subscribers of the change"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Understanding this flow helps optimize your usage patterns."}),"\n",(0,t.jsx)(n.h2,{id:"key-performance-principles",children:"Key Performance Principles"}),"\n",(0,t.jsx)(n.h3,{id:"1-minimize-unnecessary-subscriptions",children:"1. Minimize Unnecessary Subscriptions"}),"\n",(0,t.jsx)(n.p,{children:"Each subscription adds overhead to state updates. Consider these practices:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'// \u274c Subscribing to everything\nstore.subscribe(() => {\n  // Re-runs on ANY state change\n  doSomething();\n});\n\n// \u2705 Subscribe to specific paths\nstore.subscribe(() => {\n  // Only runs when user.preferences changes\n  doSomething();\n}, [["user", "preferences"]]);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-use-computed-properties-effectively",children:"2. Use Computed Properties Effectively"}),"\n",(0,t.jsx)(n.p,{children:"Computed properties are recalculated only when their dependencies change:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'// \u274c Recalculating in a subscriber\nstore.subscribe(() => {\n  const total = store.items.reduce((sum, item) => sum + item.price, 0);\n  updateTotal(total);\n});\n\n// \u2705 Using computed properties\nstore.total = computed(() => {\n  return store.items.reduce((sum, item) => sum + item.price, 0);\n});\nstore.subscribe(() => {\n  updateTotal(store.total);\n}, [["total"]]);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-avoid-deep-nesting-when-possible",children:"3. Avoid Deep Nesting When Possible"}),"\n",(0,t.jsx)(n.p,{children:"Deeply nested state can cause performance issues:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// \u274c Very deep nesting\nstore.level1.level2.level3.level4.level5.value = newValue;\n\n// \u2705 Flatter structures\nstore.settings = {\n  ui: {\n    /* UI settings */\n  },\n  data: {\n    /* Data settings */\n  },\n  permissions: {\n    /* Permission settings */\n  },\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-handle-complex-data-structures-correctly",children:"4. Handle Complex Data Structures Correctly"}),"\n",(0,t.jsx)(n.p,{children:"jods has optimized handling for circular references and complex objects:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'// \u2705 jods handles circular references gracefully\nconst user = { name: "Alice" };\nuser.self = user; // Circular reference\nstore.user = user; // This works fine in jods\n'})}),"\n",(0,t.jsx)(n.p,{children:"However, avoid creating circular references unnecessarily as they add complexity."}),"\n",(0,t.jsx)(n.h3,{id:"5-batch-updates-when-possible",children:"5. Batch Updates When Possible"}),"\n",(0,t.jsx)(n.p,{children:"When making multiple related updates, batching can improve performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'// \u274c Multiple individual updates\nstore.user.firstName = "John";\nstore.user.lastName = "Doe";\nstore.user.email = "john@example.com";\n\n// \u2705 Single batch update (future enhancement)\n// Batching API coming soon:\n// batch(() => {\n//   store.user.firstName = \'John\';\n//   store.user.lastName = \'Doe\';\n//   store.user.email = \'john@example.com\';\n// });\n\n// \u2705 Alternative approach with object assignment\nstore.user = {\n  ...store.user,\n  firstName: "John",\n  lastName: "Doe",\n  email: "john@example.com",\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"6-optimize-state-structure-for-access-patterns",children:"6. Optimize State Structure for Access Patterns"}),"\n",(0,t.jsx)(n.p,{children:"Structure your state based on how it's accessed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// \u274c Misaligned structure for access patterns\n// If you frequently access user permissions but rarely access user preferences\nstore.user = {\n  info: {\n    /* ... */\n  },\n  preferences: {\n    /* ... */\n  },\n  permissions: {\n    /* ... */\n  },\n};\n\n// \u2705 Structure aligned with access patterns\nstore.userInfo = {\n  /* ... */\n};\nstore.userPreferences = {\n  /* ... */\n}; // Rarely accessed\nstore.userPermissions = {\n  /* ... */\n}; // Frequently accessed\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-performance-techniques",children:"Advanced Performance Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"use-selector-functions-for-precise-subscriptions",children:"Use Selector Functions for Precise Subscriptions"}),"\n",(0,t.jsx)(n.p,{children:"Create selector functions to target specific parts of your state:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const selectActiveUsers = (store) =>\n  store.users.filter((user) => user.status === "active");\n\n// In a React component:\nconst activeUsers = useSelector(store, selectActiveUsers);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"memoize-expensive-computations",children:"Memoize Expensive Computations"}),"\n",(0,t.jsx)(n.p,{children:"For computations that are expensive but don't change often:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"let lastInputs = null;\nlet lastResult = null;\n\nstore.expensiveComputation = computed(() => {\n  const inputs = [store.data1, store.data2];\n\n  // If inputs haven't changed, return cached result\n  if (\n    lastInputs &&\n    lastInputs[0] === inputs[0] &&\n    lastInputs[1] === inputs[1]\n  ) {\n    return lastResult;\n  }\n\n  // Calculate new result\n  lastInputs = [...inputs];\n  lastResult = performExpensiveCalculation(inputs);\n  return lastResult;\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"consider-data-structure-size",children:"Consider Data Structure Size"}),"\n",(0,t.jsx)(n.p,{children:"Large arrays or deeply nested objects can impact performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// \u274c Storing too much in a single store\nstore.allItems = [...thousandsOfItems];\n\n// \u2705 Pagination or virtualization\nstore.currentPageItems = items.slice(pageStart, pageEnd);\nstore.pagination = {\n  currentPage: 1,\n  totalPages: Math.ceil(items.length / pageSize),\n  pageSize: 20,\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"upcoming-performance-features",children:"Upcoming Performance Features"}),"\n",(0,t.jsx)(n.p,{children:"The jods team is working on several performance-focused enhancements:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batched Updates API"}),": Group multiple updates to reduce notification overhead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Middleware Support"}),": Intercept store operations for custom optimization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enhanced Selector API"}),": More targeted subscriptions for precise reactivity"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-debugging",children:"Performance Debugging"}),"\n",(0,t.jsx)(n.p,{children:"If you encounter performance issues:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Check the number and scope of your subscriptions"}),"\n",(0,t.jsx)(n.li,{children:"Review the structure of your state object"}),"\n",(0,t.jsx)(n.li,{children:"Look for unnecessary deep nesting or circular references"}),"\n",(0,t.jsx)(n.li,{children:"Consider using more granular computed properties"}),"\n",(0,t.jsx)(n.li,{children:"Verify that you're not running expensive calculations in subscription callbacks"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/jods/es/api-reference",children:"API Reference"})," - Detailed API information"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/jods/es/fine-grained-reactivity",children:"Fine-Grained Reactivity"})," - Deep dive into the reactivity system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/jods/es/examples",children:"Examples"})," - Code examples demonstrating best practices"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);