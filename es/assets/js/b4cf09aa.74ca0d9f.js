"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9853],{3731:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"jods-journey","metadata":{"permalink":"/jods/es/blog/jods-journey","editUrl":"https://github.com/clamstew/jods/tree/main/docs/blog/2025-05-03-jods-journey.md","source":"@site/blog/2025-05-03-jods-journey.md","title":"The jods Journey: From Name-Squatting to Full Framework Integration","description":"What started as a simple npm name-squatting exercise has evolved into something far more meaningful in just under two weeks. Here\'s the story of how jods came to be.","date":"2025-05-03T00:00:00.000Z","tags":[{"inline":false,"label":"jods","permalink":"/jods/es/blog/tags/jods","description":"Posts about the jods state management library"},{"inline":false,"label":"React","permalink":"/jods/es/blog/tags/react","description":"Posts about React development"},{"inline":false,"label":"Remix","permalink":"/jods/es/blog/tags/remix","description":"Posts about the Remix framework"},{"inline":false,"label":"Signals","permalink":"/jods/es/blog/tags/signals","description":"Posts about signals and reactivity patterns"},{"inline":false,"label":"Reactivity","permalink":"/jods/es/blog/tags/reactivity","description":"Posts about reactive programming concepts"}],"readingTime":3.905,"hasTruncateMarker":false,"authors":[{"name":"Clay Stewart","title":"Creator of jods","url":"https://github.com/clamstew","page":{"permalink":"/jods/es/blog/authors/clay"},"socials":{"x":"https://x.com/clay_stewart","linkedin":"https://www.linkedin.com/in/claystewart/","github":"https://github.com/clamstew"},"imageURL":"/jods/es/img/clay-face.jpg","key":"clay"}],"frontMatter":{"slug":"jods-journey","title":"The jods Journey: From Name-Squatting to Full Framework Integration","authors":["clay"],"tags":["jods","react","remix","signals","reactivity"]},"unlisted":false},"content":"What started as a simple npm name-squatting exercise has evolved into something far more meaningful in just under two weeks. Here\'s the story of how jods came to be.\\n\\n## The Beginning: A Short Name on npm\\n\\nAbout two weeks ago, I decided to claim a short, memorable name on npm \u2014 [@jods](https://www.npmjs.com/package/jods) (JavaScript Object Dynamics System). Initially, after playing around with [BullMQ](https://github.com/taskforcesh/bullmq), I thought it might become a job queuing system (jods = jobs, get it?). But I quickly pivoted when I had a loose idea about creating a state management library instead. At that point, I just wanted to secure a name that was easy to remember and type.\\n\\n## Creating a Simple API\\n\\nAfter securing the name, I started to flesh out what this library could be. I knew I wanted something with:\\n\\n- \ud83c\udf1f A simple, intuitive API\\n- \ud83c\udfaf Zero dependencies\\n- \ud83d\udd0c Easy integration with any framework\\n- \ud83d\udcf8 JSON snapshot capability out of the box\\n\\nI quickly realized that with a proxy-based approach, I could create something that felt natural to use \u2014 just plain JavaScript objects that magically become reactive.\\n\\n## React and Beyond\\n\\nOnce I had the core reactivity system working, I moved on to integrating with React. This is where things got interesting. I found that with the proxy approach, integrating with React was almost trivial:\\n\\n```jsx\\n// Create a store\\nconst user = store({\\n  firstName: \\"Burt\\",\\n  lastName: \\"Macklin\\",\\n  mood: \\"curious\\",\\n});\\n\\n// In your React component\\nfunction Profile() {\\n  const userData = useJods(user);\\n\\n  return (\\n    <div>\\n      <h1>Hello, {userData.firstName}</h1>\\n      <p>Mood: {userData.mood}</p>\\n\\n      {/* Direct state mutations - no actions, reducers, or dispatchers needed */}\\n      <button onClick={() => (user.mood = \\"sneaky\\")}>Go Undercover</button>\\n      <button onClick={() => (user.firstName = \\"Burt Macklin\\")}>\\n        Use FBI Name\\n      </button>\\n    </div>\\n  );\\n}\\n```\\n\\nThe simplicity compared to some other libraries surprised me \ud83e\udd14. No need for selectors, actions, or reducers \u2014 just directly use the object. That \\"aha moment\\" when I realized I could just write `user.mood = \\"sneaky\\"` and have the UI update automatically was when I knew this approach had merit. \ud83d\ude4c\\n\\n## The Signal Revolution\\n\\nAs the project progressed, I couldn\'t ignore the growing popularity of signals in frameworks like Preact, Solid, and Angular. The [proposed TC39 signals spec](https://github.com/tc39/proposal-signals) caught my attention, and I even [opened an issue](https://github.com/clamstew/jods/issues/11) to track our potential adoption of native signals.\\n\\nSo one morning, I created a [branch to rewrite jods with signals](https://github.com/clamstew/jods/pull/20) as the foundation. This enabled more fine-grained reactivity \u2014 only updating components when the specific properties they use change, rather than the entire store. The community showed interest too, with discussions emerging around [signal integration strategies](https://github.com/clamstew/jods/issues/23).\\n\\n## Enter Remix: Rethinking the Model Layer\\n\\nWith the core reactivity model working well, I decided to tackle one of my favorite meta-frameworks: Remix. Remix is incredibly powerful, but there\'s sometimes boilerplate when setting up loaders, actions, and form handling.\\n\\nI realized jods could serve as a bridge \u2014 creating a more model-centric approach where your data models define their:\\n\\n- \ud83d\udcdd Schema validation\\n- \ud83d\udd04 Server-side loaders\\n- \ud83d\udccb Form handlers\\n- \u26a1\ufe0f Client-side reactivity\\n\\nThe result is what we now have in `jods/remix` \u2014 a streamlined approach that reduces boilerplate and brings a more familiar model-view pattern to Remix development:\\n\\n```typescript\\n// Define your model once\\nexport const user = defineStore({\\n  name: \\"user\\",\\n  schema: z.object({\\n    name: z.string(),\\n    email: z.string().email(),\\n  }),\\n  defaults: {\\n    name: \\"Guest\\",\\n    email: \\"\\",\\n  },\\n  handlers: {\\n    async updateProfile({ current, form }) {\\n      // Update logic\\n    },\\n  },\\n  loader: async ({ request }) => {\\n    // Load user data\\n  },\\n});\\n\\n// Export ready-to-use loaders and actions\\nexport const loader = withJods([user]);\\nexport const action = user.action;\\n```\\n\\nThen in your components, simply use:\\n\\n```tsx\\nfunction ProfilePage() {\\n  const userData = useJodsStore(user);\\n  const form = useJodsForm(user.actions.updateProfile);\\n\\n  return (\\n    <form {...form.props}>\\n      <input name=\\"name\\" defaultValue={userData.name} />\\n      <button type=\\"submit\\">Update</button>\\n    </form>\\n  );\\n}\\n```\\n\\n## The Road Ahead\\n\\nWhile I\'m thrilled with how far jods has come in such a short time, there\'s still much more to explore:\\n\\n- \ud83d\udcbe Enhanced persistence options ([#5](https://github.com/clamstew/jods/issues/5))\\n- \ud83d\udd04 Remote syncing capabilities ([#7](https://github.com/clamstew/jods/issues/7))\\n- \ud83d\udce1 Streaming updates from server sources ([#9](https://github.com/clamstew/jods/issues/9))\\n- \u23f0 Time-travel debugging\\n- \ud83d\udee0\ufe0f Developer tools\\n\\n## Final Thoughts\\n\\nWhat started as a simple name registration has evolved into a project I\'m genuinely excited about. jods reflects my belief that state management should be as simple and intuitive as possible, while still being powerful enough for real-world applications.\\n\\nI never expected to build all this in less than two weeks, but it\'s amazing what you can accomplish when you\'re passionate about solving a problem you care about.\\n\\nI\'d love to hear your thoughts and see what you build with jods!\\n\\n\u2014 [clamstew](https://www.github.com/clamstew)"}]}}')}}]);