"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9373],{558:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sync/framework-usage","title":"Framework Integration","description":"Using the sync API with React, Preact, and Remix","source":"@site/docs/sync/framework-usage.md","sourceDirName":"sync","slug":"/sync/framework-usage","permalink":"/jods/es/sync/framework-usage","draft":false,"unlisted":false,"editUrl":"https://github.com/clamstew/jods/tree/main/docs/docs/sync/framework-usage.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Framework Integration","description":"Using the sync API with React, Preact, and Remix"},"sidebar":"jodsSidebar","previous":{"title":"\ud83d\udd0c Framework Integration","permalink":"/jods/es/sync/framework-integration"},"next":{"title":"\ud83d\uddbc\ufe0f Framework Examples","permalink":"/jods/es/sync/framework-examples"}}');var o=t(3420),r=t(3774);const c={sidebar_position:3,title:"Framework Integration",description:"Using the sync API with React, Preact, and Remix"},a="Framework Integration",i={},d=[{value:"React Integration",id:"react-integration",level:2},{value:"Basic React Setup",id:"basic-react-setup",level:3},{value:"Connection Status Hook",id:"connection-status-hook",level:3},{value:"Preact Integration",id:"preact-integration",level:2},{value:"Remix Integration",id:"remix-integration",level:2},{value:"Setting Up Sync in Remix",id:"setting-up-sync-in-remix",level:3},{value:"Remix Integration with Multiple Synced Stores",id:"remix-integration-with-multiple-synced-stores",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Error Handling and Reconnection",id:"error-handling-and-reconnection",level:3},{value:"Custom Transport Adapters",id:"custom-transport-adapters",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"framework-integration",children:"Framework Integration"})}),"\n",(0,o.jsxs)(e.p,{children:["This guide shows how to use the jods ",(0,o.jsx)(e.code,{children:"sync"})," API with React, Preact, and Remix frameworks."]}),"\n",(0,o.jsx)(e.h2,{id:"react-integration",children:"React Integration"}),"\n",(0,o.jsx)(e.p,{children:"React applications can leverage the jods sync API to create real-time collaborative experiences and cross-tab synchronization."}),"\n",(0,o.jsx)(e.h3,{id:"basic-react-setup",children:"Basic React Setup"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'import { useEffect, useState } from "react";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/react";\n\n// Create a store\nconst chatStore = store({\n  messages: [],\n  users: [],\n  status: "disconnected",\n});\n\nfunction ChatApp() {\n  const state = useJods(chatStore);\n  const [syncActive, setSyncActive] = useState(false);\n\n  // Set up WebSocket connection and sync\n  useEffect(() => {\n    // Create WebSocket connection\n    const socket = new WebSocket("wss://chat-server.example.com");\n\n    // Start syncing when socket is connected\n    const stopSync = sync(socket, chatStore, {\n      // Secure sync by only allowing specific properties\n      allowKeys: ["messages", "users", "status"],\n      // Reduce network traffic by throttling updates\n      throttleMs: 300,\n      // Error handling\n      onError: (err) => console.error("Sync error:", err),\n    });\n\n    setSyncActive(true);\n\n    // Update connection status based on socket state\n    socket.addEventListener("open", () => {\n      chatStore.status = "connected";\n    });\n\n    socket.addEventListener("close", () => {\n      chatStore.status = "disconnected";\n    });\n\n    // Clean up on component unmount\n    return () => {\n      stopSync();\n      socket.close();\n      setSyncActive(false);\n    };\n  }, []);\n\n  return (\n    <div>\n      <div className={`status ${state.status}`}>\n        {state.status === "connected" ? "Connected" : "Disconnected"}\n        {syncActive && " (Sync Active)"}\n      </div>\n\n      <div className="messages">\n        {state.messages.map((msg) => (\n          <div key={msg.id} className="message">\n            <strong>{msg.user}:</strong> {msg.text}\n          </div>\n        ))}\n      </div>\n\n      <button\n        onClick={() => {\n          chatStore.messages.push({\n            id: Date.now(),\n            user: "Local User",\n            text: `Message at ${new Date().toLocaleTimeString()}`,\n          });\n        }}\n      >\n        Send Message\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"connection-status-hook",children:"Connection Status Hook"}),"\n",(0,o.jsx)(e.p,{children:"For reusable connection status management, you can create a custom hook:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'function useSyncConnection(store, socketUrl, options = {}) {\n  const [status, setStatus] = useState("disconnected");\n\n  useEffect(() => {\n    const socket = new WebSocket(socketUrl);\n    let stopSync = null;\n\n    const handleOpen = () => {\n      setStatus("connected");\n      store.connectionStatus = "connected";\n\n      // Start sync when connected\n      stopSync = sync(socket, store, options);\n    };\n\n    const handleClose = () => {\n      setStatus("disconnected");\n      store.connectionStatus = "disconnected";\n    };\n\n    socket.addEventListener("open", handleOpen);\n    socket.addEventListener("close", handleClose);\n\n    // If already open, handle immediately\n    if (socket.readyState === WebSocket.OPEN) {\n      handleOpen();\n    }\n\n    return () => {\n      if (stopSync) stopSync();\n      socket.removeEventListener("open", handleOpen);\n      socket.removeEventListener("close", handleClose);\n      socket.close();\n    };\n  }, [store, socketUrl, options]);\n\n  return status;\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"preact-integration",children:"Preact Integration"}),"\n",(0,o.jsx)(e.p,{children:"The Preact integration is very similar to React, with minor differences in imports and hook usage."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'import { useEffect, useState } from "preact/hooks";\nimport { store, sync } from "jods";\nimport { useJods } from "jods/preact";\n\n// Create a store\nconst todoStore = store({\n  todos: [],\n  filter: "all",\n  syncStatus: "inactive",\n});\n\nfunction TodoApp() {\n  const state = useJods(todoStore);\n\n  // Set up sync with BroadcastChannel for cross-tab sync\n  useEffect(() => {\n    // Create a channel with a unique name for this app\n    const channel = new BroadcastChannel("todo-app-sync");\n\n    // Start syncing between tabs\n    const stopSync = sync(channel, todoStore, {\n      throttleMs: 100,\n      onError: (err) => {\n        console.error("Sync error:", err);\n        todoStore.syncStatus = "error";\n      },\n    });\n\n    todoStore.syncStatus = "active";\n\n    return () => {\n      stopSync();\n      channel.close();\n      todoStore.syncStatus = "inactive";\n    };\n  }, []);\n\n  return (\n    <div>\n      <div class="sync-status">\n        Sync Status: {state.syncStatus}\n        {state.syncStatus === "active" && (\n          <span> (Changes sync across browser tabs)</span>\n        )}\n      </div>\n\n      <ul>\n        {state.todos\n          .filter((todo) => {\n            if (state.filter === "completed") return todo.completed;\n            if (state.filter === "active") return !todo.completed;\n            return true; // \'all\' filter\n          })\n          .map((todo) => (\n            <li key={todo.id}>\n              <input\n                type="checkbox"\n                checked={todo.completed}\n                onChange={() => {\n                  todo.completed = !todo.completed;\n                }}\n              />\n              <span\n                style={{\n                  textDecoration: todo.completed ? "line-through" : "none",\n                }}\n              >\n                {todo.text}\n              </span>\n            </li>\n          ))}\n      </ul>\n\n      <div class="filters">\n        <button onClick={() => (todoStore.filter = "all")}>All</button>\n        <button onClick={() => (todoStore.filter = "active")}>Active</button>\n        <button onClick={() => (todoStore.filter = "completed")}>\n          Completed\n        </button>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"remix-integration",children:"Remix Integration"}),"\n",(0,o.jsx)(e.p,{children:"Remix has special considerations for server-side rendering (SSR) and client hydration. The sync API should only activate after hydration is complete."}),"\n",(0,o.jsx)(e.h3,{id:"setting-up-sync-in-remix",children:"Setting Up Sync in Remix"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'import { useEffect, useState } from "react";\nimport { json } from "@remix-run/node";\nimport { useLoaderData } from "@remix-run/react";\nimport { defineStore } from "jods/remix";\nimport { useJodsStore } from "jods/remix";\nimport { sync } from "jods";\n\n// Define a jods store for Remix\nexport const chatStore = defineStore({\n  name: "chat",\n  schema: z.object({\n    messages: z.array(\n      z.object({\n        id: z.string(),\n        text: z.string(),\n        user: z.string(),\n        timestamp: z.number(),\n      })\n    ),\n    users: z.array(\n      z.object({\n        id: z.string(),\n        name: z.string(),\n        status: z.enum(["online", "offline"]),\n      })\n    ),\n    syncStatus: z.enum(["connected", "disconnected", "error"]).optional(),\n  }),\n  // Load initial data from server\n  loader: async () => {\n    return {\n      messages: await loadMessagesFromDb(),\n      users: await loadUsersFromDb(),\n    };\n  },\n  // Handle form submissions\n  handlers: {\n    async addMessage({ current, form }) {\n      const text = form.get("message");\n      if (!text || typeof text !== "string") {\n        return current;\n      }\n\n      const newMessage = {\n        id: crypto.randomUUID(),\n        text,\n        user: "Current User",\n        timestamp: Date.now(),\n      };\n\n      return {\n        ...current,\n        messages: [...current.messages, newMessage],\n      };\n    },\n  },\n});\n\nexport async function loader() {\n  return json(await chatStore.loader());\n}\n\nexport async function action({ request }) {\n  const form = await request.formData();\n  return json(await chatStore.actions.addMessage({ form }));\n}\n\nexport default function ChatRoute() {\n  const initialData = useLoaderData();\n  const state = useJodsStore(chatStore);\n  const [isHydrated, setIsHydrated] = useState(false);\n  const [syncActive, setSyncActive] = useState(false);\n\n  // Detect client-side hydration\n  useEffect(() => {\n    setIsHydrated(true);\n  }, []);\n\n  // Only set up sync AFTER hydration is complete\n  useEffect(() => {\n    if (!isHydrated) return;\n\n    const socket = new WebSocket("wss://chat-server.example.com");\n\n    const stopSync = sync(socket, chatStore, {\n      // Don\'t sync syncStatus property to server\n      allowKeys: ["messages", "users"],\n      throttleMs: 300,\n      onError: (err) => {\n        console.error("Sync error:", err);\n        chatStore.syncStatus = "error";\n      },\n    });\n\n    socket.addEventListener("open", () => {\n      chatStore.syncStatus = "connected";\n      setSyncActive(true);\n    });\n\n    socket.addEventListener("close", () => {\n      chatStore.syncStatus = "disconnected";\n      setSyncActive(false);\n    });\n\n    return () => {\n      stopSync();\n      socket.close();\n    };\n  }, [isHydrated]);\n\n  return (\n    <div>\n      <div className="hydration-status">\n        {isHydrated ? "Client Hydrated" : "Server Rendered"}\n      </div>\n\n      <div className="sync-status">\n        {syncActive ? "Real-time sync active" : "Sync inactive"}\n        {state.syncStatus && ` (${state.syncStatus})`}\n      </div>\n\n      <div className="messages">\n        {state.messages.map((msg) => (\n          <div key={msg.id} className="message">\n            <strong>{msg.user}:</strong> {msg.text}\n            <span className="timestamp">\n              {new Date(msg.timestamp).toLocaleTimeString()}\n            </span>\n          </div>\n        ))}\n      </div>\n\n      <form method="post">\n        <input name="message" placeholder="Type message..." />\n        <button type="submit">Send</button>\n      </form>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"remix-integration-with-multiple-synced-stores",children:"Remix Integration with Multiple Synced Stores"}),"\n",(0,o.jsx)(e.p,{children:"For more complex Remix applications, you may need to sync multiple stores with different sockets or channels:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// In your route component\nexport default function Dashboard() {\n  const [isHydrated, setIsHydrated] = useState(false);\n\n  // Detect client hydration\n  useEffect(() => {\n    setIsHydrated(true);\n  }, []);\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n\n      {/* Each component manages its own sync */}\n      <UserList isHydrated={isHydrated} />\n      <ChatPanel isHydrated={isHydrated} />\n      <NotificationCenter isHydrated={isHydrated} />\n    </div>\n  );\n}\n\n// User list component with sync\nfunction UserList({ isHydrated }) {\n  const state = useJodsStore(userStore);\n\n  // Only set up sync after hydration\n  useEffect(() => {\n    if (!isHydrated) return;\n\n    const socket = new WebSocket('wss://users-api.example.com');\n    const stopSync = sync(socket, userStore, {\n      allowKeys: ['users', 'filter'],\n      prefix: 'users', // Use prefix for multiplexing\n    });\n\n    return () => {\n      stopSync();\n      socket.close();\n    };\n  }, [isHydrated]);\n\n  return (/* Component JSX */);\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.strong,{children:["Always use ",(0,o.jsx)(e.code,{children:"allowKeys"})," option"]})," to limit which properties can be synced:"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'const stopSync = sync(socket, store, {\n  allowKeys: ["publicData", "sharedSettings"],\n  // Don\'t sync these even if nested under allowKeys\n  sensitiveKeys: ["publicData.apiKeys", "sharedSettings.tokens"],\n});\n'})}),"\n",(0,o.jsxs)(e.ol,{start:"2",children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Never sync sensitive data"})," like authentication tokens, passwords, or personal information."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Validate incoming data"})," before applying changes:"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'const stopSync = sync(socket, store, {\n  onPatchReceive: (patch) => {\n    // Validate patch before applying\n    try {\n      MySchema.parse(patch.changes);\n      return patch; // Valid, proceed with sync\n    } catch (error) {\n      console.error("Invalid incoming data:", error);\n      return null; // Reject the patch\n    }\n  },\n});\n'})}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use throttling"})," to reduce network traffic:"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"const stopSync = sync(socket, store, {\n  throttleMs: 300, // Only send updates every 300ms at most\n});\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"2",children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sync only what's needed"})," to minimize payload size:"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"// For fine-grained control over what gets synced\nconst stopSync = sync(socket, store, {\n  filter: (changes) => {\n    // Only sync changes that meet certain criteria\n    if (changes.hugeDataArray) {\n      // Don't sync the entire array, just a summary\n      changes.hugeDataSummary = summarizeData(changes.hugeDataArray);\n      delete changes.hugeDataArray;\n    }\n    return changes;\n  },\n});\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"3",children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Consider syncing status separately"})," from data for more responsive UIs:"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'// Separate stores for data and status\nconst dataStore = store({\n  /* ... */\n});\nconst statusStore = store({\n  connected: false,\n  lastSync: null,\n});\n\n// In component\nuseEffect(() => {\n  const socket = new WebSocket("wss://example.com");\n\n  socket.addEventListener("open", () => {\n    statusStore.connected = true;\n    statusStore.lastSync = Date.now();\n  });\n\n  const stopSync = sync(socket, dataStore, {\n    onDiffSend: () => {\n      statusStore.lastSync = Date.now();\n    },\n    onPatchReceive: () => {\n      statusStore.lastSync = Date.now();\n    },\n  });\n\n  return () => {\n    stopSync();\n    socket.close();\n  };\n}, []);\n'})}),"\n",(0,o.jsx)(e.h3,{id:"error-handling-and-reconnection",children:"Error Handling and Reconnection"}),"\n",(0,o.jsx)(e.p,{children:"For robust error handling and automatic reconnection:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:"function ChatApp() {\n  const state = useJods(chatStore);\n  const [socket, setSocket] = useState(null);\n  const [stopSyncFn, setStopSyncFn] = useState(null);\n\n  // Connect and setup sync\n  const connectAndSync = useCallback(() => {\n    if (socket) {\n      socket.close();\n    }\n\n    if (stopSyncFn) {\n      stopSyncFn();\n    }\n\n    const newSocket = new WebSocket('wss://chat-server.example.com');\n    setSocket(newSocket);\n\n    newSocket.addEventListener('open', () => {\n      chatStore.status = 'connected';\n      const stopSync = sync(newSocket, chatStore, {\n        allowKeys: ['messages', 'users', 'status'],\n        onError: (err) => {\n          console.error('Sync error:', err);\n          chatStore.status = 'error';\n        }\n      });\n      setStopSyncFn(() => stopSync);\n    });\n\n    newSocket.addEventListener('close', () => {\n      chatStore.status = 'disconnected';\n      // Attempt reconnection after delay\n      setTimeout(connectAndSync, 3000);\n    });\n\n    newSocket.addEventListener('error', (err) => {\n      console.error('Socket error:', err);\n      chatStore.status = 'error';\n      // Socket will close automatically after error\n    });\n  }, [socket, stopSyncFn]);\n\n  // Initial connection\n  useEffect(() => {\n    connectAndSync();\n\n    return () => {\n      if (stopSyncFn) stopSyncFn();\n      if (socket) socket.close();\n    };\n  }, []);\n\n  return (/* Component JSX */);\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"custom-transport-adapters",children:"Custom Transport Adapters"}),"\n",(0,o.jsx)(e.p,{children:"You can create custom adapters for different transport mechanisms:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-jsx",children:'// Socket.io adapter\nfunction createSocketIOAdapter(socket) {\n  return {\n    send: (message) => {\n      socket.emit("jods-sync", message);\n    },\n    // Set up event listener\n    addEventListener: (type, listener) => {\n      if (type === "message") {\n        socket.on("jods-sync", (data) => {\n          listener({ data: JSON.stringify(data) });\n        });\n      }\n    },\n    removeEventListener: (type, listener) => {\n      if (type === "message") {\n        socket.off("jods-sync");\n      }\n    },\n  };\n}\n\n// Usage\nconst socket = io("https://example.com");\nconst socketAdapter = createSocketIOAdapter(socket);\nconst stopSync = sync(socketAdapter, store);\n'})})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}},3774:(n,e,t)=>{t.d(e,{R:()=>c,x:()=>a});var s=t(6672);const o={},r=s.createContext(o);function c(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:c(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);